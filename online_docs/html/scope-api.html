
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Scope API &#8212; ChipWhisperer 5.7.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxcontrib-images/LightBox2/lightbox2/dist/css/lightbox.css" />
    <link rel="stylesheet" type="text/css" href="_static/backup.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinxcontrib-images/LightBox2/lightbox2/dist/js/lightbox-plus-jquery.min.js"></script>
    <script src="_static/sphinxcontrib-images/LightBox2/lightbox2-customize/jquery-noconflict.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Updating Firmware" href="firmware.html" />
    <link rel="prev" title="Virtual Machine Installs" href="virtual-box-inst.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">ChipWhisperer</h1>
    
  </a>
</p>



<p class="blurb">Side-Channel analysis tool-chain.</p>









  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Scope API</a><ul>
<li><a class="reference internal" href="#openadc-scope">OpenADC Scope</a><ul>
<li><a class="reference internal" href="#scope-gain">scope.gain</a></li>
<li><a class="reference internal" href="#scope-adc">scope.adc</a><ul>
<li><a class="reference internal" href="#scope-adc-pro-husky-only">scope.adc Pro/Husky Only</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scope-clock">scope.clock</a><ul>
<li><a class="reference internal" href="#scope-clock-lite-pro-only">scope.clock (Lite/Pro Only)</a></li>
<li><a class="reference internal" href="#scope-clock-husky-only">scope.clock (Husky Only)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scope-io">scope.io</a></li>
<li><a class="reference internal" href="#scope-trigger">scope.trigger</a><ul>
<li><a class="reference internal" href="#scope-trigger-pro-only">scope.trigger (Pro Only)</a></li>
<li><a class="reference internal" href="#scope-trigger-husky-only">scope.trigger (Husky Only)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scope-glitch">scope.glitch</a><ul>
<li><a class="reference internal" href="#scope-glitch-husky-only">scope.glitch (Husky Only)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pro-husky-only-featuers">Pro/Husky Only Featuers</a><ul>
<li><a class="reference internal" href="#sad">SAD</a></li>
</ul>
</li>
<li><a class="reference internal" href="#husky-only-features">Husky Only Features</a><ul>
<li><a class="reference internal" href="#scope-uarttrigger">scope.UARTTrigger</a></li>
<li><a class="reference internal" href="#scope-la">scope.LA</a></li>
<li><a class="reference internal" href="#scope-ads4128settings">scope.ADS4128Settings</a></li>
<li><a class="reference internal" href="#scope-leds">scope.LEDs</a></li>
<li><a class="reference internal" href="#scope-errors">scope.errors</a></li>
<li><a class="reference internal" href="#scope-userio">scope.userio</a></li>
<li><a class="reference internal" href="#scope-xadc">scope.XADC</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#chipwhisperer-nano-scope">ChipWhisperer Nano Scope</a><ul>
<li><a class="reference internal" href="#adc">adc</a></li>
<li><a class="reference internal" href="#io">io</a></li>
<li><a class="reference internal" href="#id1">glitch</a></li>
</ul>
</li>
<li><a class="reference internal" href="#common-scope-attributes">Common Scope Attributes</a></li>
<li><a class="reference internal" href="#firmware-update">Firmware Update</a></li>
</ul>
</li>
</ul>

  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="scope-api">
<span id="api-scope"></span><h1>Scope API<a class="headerlink" href="#scope-api" title="Permalink to this heading">¶</a></h1>
<p>The scope object is used to control the capture/glitch
portion of the ChipWhisperer device.</p>
<p>The easiest way to create a scope object is via the <a class="reference internal" href="#chipwhisperer.scope" title="chipwhisperer.scope"><code class="xref py py-func docutils literal notranslate"><span class="pre">chipwhisperer.scope()</span></code></a> function,
which will connect to a ChipWhisperer device and return a scope object of the correct type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">chipwhisperer</span> <span class="k">as</span> <span class="nn">cw</span>
<span class="n">scope</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">scope</span><span class="p">()</span>
</pre></div>
</div>
<p>There are currently two types of scopes:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#api-scope-openadc"><span class="std std-ref">OpenADC Scope</span></a> (Lite, Pro, Husky)</p></li>
<li><p><a class="reference internal" href="#api-scope-cwnano"><span class="std std-ref">ChipWhisperer Nano Scope</span></a> (Nano)</p></li>
</ul>
</div></blockquote>
<p>These scope objects also inherit common methods from <a class="reference internal" href="#api-scope-common"><span class="std std-ref">Common Scope Attributes</span></a></p>
<dl class="py data">
<dt class="sig sig-object py" id="chipwhisperer.scope">
<span class="sig-name descname"><span class="pre">scope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scope_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idProduct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bitstream</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prog_speed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><em class="property"><span class="w"> </span><span class="pre">chipwhisperer.scope()</span></em><a class="headerlink" href="#chipwhisperer.scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a scope object and connect to it.</p>
<p>This function allows any type of scope to be created. By default, the
object created is based on the attached hardware (OpenADC for
CWLite/CW1200, CWNano for CWNano).</p>
<dl class="simple">
<dt>Scope Types:</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="#chipwhisperer.scopes.OpenADC" title="chipwhisperer.scopes.OpenADC"><code class="xref py py-class docutils literal notranslate"><span class="pre">scopes.OpenADC</span></code></a> (Pro and Lite)</p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.CWNano" title="chipwhisperer.scopes.CWNano"><code class="xref py py-class docutils literal notranslate"><span class="pre">scopes.CWNano</span></code></a> (Nano)</p></li>
</ul>
</dd>
</dl>
<p>If multiple chipwhisperers are connected, the serial number of the one you
want to connect to can be specified by passing sn=&lt;SERIAL_NUMBER&gt;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scope_type</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Type</span></code>[<code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<a class="reference internal" href="#chipwhisperer.scopes.OpenADC" title="chipwhisperer.capture.scopes.OpenADC.OpenADC"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenADC</span></code></a>, <a class="reference internal" href="#chipwhisperer.scopes.CWNano" title="chipwhisperer.capture.scopes.cwnano.CWNano"><code class="xref py py-class docutils literal notranslate"><span class="pre">CWNano</span></code></a>]]]) – Scope type to connect to. Types
can be found in chipwhisperer.scopes. If None, will try to detect
the type of ChipWhisperer connected. Defaults to None.</p></li>
<li><p><strong>name</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – <p>model name of the ChipWhisperer that you want to
connect to. Alternative to specifying the serial number when
multiple ChipWhisperers, all of different type, are connected.
Defaults to None. Valid values:</p>
<ul>
<li><p>Lite</p></li>
<li><p>Pro</p></li>
<li><p>Husky</p></li>
</ul>
</p></li>
<li><p><strong>idProduct</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]) – <p>idProduct of the ChipWhisperer that you want to
connect to. Alternative to specifying the serial number when
multiple ChipWhisperers, all of different type, are connected.
Defaults to None. Valid values:</p>
<ul>
<li><p>0xace2: CW-Lite</p></li>
<li><p>0xace3: CW-Pro</p></li>
<li><p>0xace5: CW-Husky</p></li>
</ul>
</p></li>
<li><p><strong>sn</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Serial number of ChipWhisperer that you want to
connect to. sn is required if more than one ChipWhisperer of the
same type is connected (i.e. two CWNano’s or a CWLite and CWPro).
Defaults to None.</p></li>
<li><p><strong>bitstream</strong> (<code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]) – Path to bitstream to program. If None,
programs default bitstream. Optional, defaults to None. Ignored
on Nano.</p></li>
<li><p><strong>force</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, always erase and program
FPGA. If False, only erase and program FPGA if it
is currently blank. Defaults to False. Ignored on Nano.</p></li>
<li><p><strong>prog_speed</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Sets the FPGA programming speed for Lite, Pro, and Husky.
If you get programming errors, try turning this down.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code>[<a class="reference internal" href="#chipwhisperer.scopes.OpenADC" title="chipwhisperer.capture.scopes.OpenADC.OpenADC"><code class="xref py py-class docutils literal notranslate"><span class="pre">OpenADC</span></code></a>, <a class="reference internal" href="#chipwhisperer.scopes.CWNano" title="chipwhisperer.capture.scopes.cwnano.CWNano"><code class="xref py py-class docutils literal notranslate"><span class="pre">CWNano</span></code></a>]</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Connected scope object.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>OSError</strong> – Can be raised for issues connecting to the chipwhisperer, such
    as not having permission to access the USB device or no ChipWhisperer
    being connected.</p></li>
<li><p><strong>Warning</strong> – Raised if multiple chipwhisperers are connected, but the type
    and/or the serial numbers are not specified</p></li>
</ul>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 5.1: </span>Added autodetection of scope_type</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 5.5: </span>Added idProduct, name, bitstream, and force parameters.</p>
</div>
</dd></dl>

<p>As of ChipWhisperer 5.6.2, ChipWhisperer can find all connected devices:</p>
<dl class="py data">
<dt class="sig sig-object py" id="chipwhisperer.list_devices">
<span class="sig-name descname"><span class="pre">list_devices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idProduct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_sn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_hw_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><em class="property"><span class="w"> </span><span class="pre">chipwhisperer.list_devices()</span></em><a class="headerlink" href="#chipwhisperer.list_devices" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of devices by NewAE (VID 0x2b3e) currently connected</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>idProduct</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – List of PIDs to restrict devices to. If None, do
not restrict. Defaults to None.</p></li>
<li><p><strong>get_sn</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to try to access serial number. Can fail if another
process is connected or if we don’t have permission to access the device. Defaults to True.</p></li>
<li><p><strong>get_hw_loc</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether or not to access the hardware location of the device.
Can fail due to the same reasons as above. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of dicts with fields {‘name’: str, ‘sn’, str, ‘hw_loc’: (int, int)}</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[dict]</p>
</dd>
</dl>
<p>If an unknown NewAE device is connected, ‘name’ will be ‘unknown’. If ‘sn’ or ‘hw_loc’
are not desired, or cannot be accessed, they will be None.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.6.2.</span></p>
</div>
</dd></dl>

<section id="openadc-scope">
<span id="api-scope-openadc"></span><h2>OpenADC Scope<a class="headerlink" href="#openadc-scope" title="Permalink to this heading">¶</a></h2>
<p>Supported scopes:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://rtfm.newae.com/Capture/ChipWhisperer-Lite/">ChipWhisperer-Lite</a></p></li>
<li><p><a class="reference external" href="https://rtfm.newae.com/Capture/ChipWhisperer-Pro/">ChipWhisperer-Pro</a></p></li>
<li><p><a class="reference external" href="https://www.crowdsupply.com/newae/chipwhisperer-husky">ChipWhisperer-Husky</a></p></li>
</ul>
</div></blockquote>
<p>Usage examples:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://github.com/newaetech/chipwhisperer-jupyter/tree/master/courses/sca101">Power Analysis</a></p></li>
<li><p><a class="reference external" href="https://github.com/newaetech/chipwhisperer-jupyter/tree/master/courses/fault101">Glitch</a></p></li>
<li><p><a class="reference external" href="https://github.com/newaetech/chipwhisperer-jupyter/blob/master/demos/CW-Pro%20Using%20SAD%20(Analog%20Pattern)%20Trigger%20-%20Attacking%20AES.ipynb">Pro features</a></p></li>
<li><p><a class="reference external" href="https://github.com/newaetech/chipwhisperer-jupyter/blob/master/demos/husky_glitch.ipynb">Husky glitching</a></p></li>
</ul>
</div></blockquote>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">OpenADC</span></span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC" title="Permalink to this definition">¶</a></dt>
<dd><p>OpenADC scope object.</p>
<p>This class contains the public API for the OpenADC hardware, including the
ChipWhisperer Lite/ CW1200 Pro boards. It includes specific settings for
each of these devices.</p>
<p>To connect to one of these devices, the easiest method is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">chipwhisperer</span> <span class="k">as</span> <span class="nn">cw</span>
<span class="n">scope</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="n">scope_type</span><span class="o">=</span><span class="n">cw</span><span class="o">.</span><span class="n">scopes</span><span class="o">.</span><span class="n">OpenADC</span><span class="p">)</span>
</pre></div>
</div>
<p>Some sane default settings are available via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scope</span><span class="o">.</span><span class="n">default_setup</span><span class="p">()</span>
</pre></div>
</div>
<p>This code will automatically detect an attached ChipWhisperer device and
connect to it.</p>
<p>For more help about scope settings, try help() on each of the ChipWhisperer
scope submodules (scope.gain, scope.adc, scope.clock, scope.io,
scope.trigger, and scope.glitch):</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes._OpenADCInterface.GainSettings" title="chipwhisperer.capture.scopes._OpenADCInterface.GainSettings"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.gain</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings" title="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.adc</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings" title="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.clock</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings" title="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.io</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.TriggerSettings" title="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.TriggerSettings"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.trigger</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings" title="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.glitch</span> <span class="pre">(Lite/Pro)</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.OpenADC.default_setup" title="chipwhisperer.scopes.OpenADC.default_setup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.default_setup</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.OpenADC.con" title="chipwhisperer.scopes.OpenADC.con"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.con</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.OpenADC.dis" title="chipwhisperer.scopes.OpenADC.dis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.dis</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.OpenADC.arm" title="chipwhisperer.scopes.OpenADC.arm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.arm</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.OpenADC.get_last_trace" title="chipwhisperer.scopes.OpenADC.get_last_trace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.get_last_trace</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.get_serial_ports" title="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.get_serial_ports"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.get_serial_ports</span></code></a></p></li>
</ul>
</div></blockquote>
<p>If you have a CW1200 ChipWhisperer Pro/Husky, you have access to some additional features:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD" title="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.SAD</span></code></a></p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.DecodeIO</span></code></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.stream_mode" title="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.stream_mode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.adc.stream_mode</span></code></a></p></li>
</ul>
</div></blockquote>
<p>Inherits from <a class="reference internal" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface" title="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.arm">
<span class="sig-name descname"><span class="pre">arm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.arm" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup scope to begin capture/glitching when triggered.</p>
<p>The scope must be armed before capture or glitching (when set to
‘ext_single’) can begin.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>OSError</strong> – Scope isn’t connected.</p></li>
<li><p><strong>Exception</strong> – Error when arming. This method catches these and
    disconnects before reraising them.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.capture">
<span class="sig-name descname"><span class="pre">capture</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poll_done</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.capture" title="Permalink to this definition">¶</a></dt>
<dd><p>Captures trace. Scope must be armed before capturing.</p>
<p>Blocks until scope triggered (or times out),
then disarms scope and copies data back.</p>
<p>Read captured data out with <code class="code docutils literal notranslate"><span class="pre">scope.get_last_trace()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>poll_done</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – Supported by Husky only. Poll
Husky to find out when it’s done capturing, instead of
calculating the capture time based on the capture parameters.
Can result in slightly faster captures when the number of
samples is high. Defaults to False.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if capture timed out, false if it didn’t.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>IOError</strong> – Unknown failure.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 5.6.1: </span>Added poll_done parameter for Husky</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.capture_segmented">
<span class="sig-name descname"><span class="pre">capture_segmented</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.capture_segmented" title="Permalink to this definition">¶</a></dt>
<dd><p>Captures trace in segment mode, returns as many segments as buffer holds.</p>
<p>Timeouts not handled yet properly (function will lock). Be sure you are generating
enough triggers for segmented mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if capture timed out, false if it didn’t.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>IOError</strong> – Unknown failure.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.5: </span>Added segmented capture (requires custom bitstream)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.cglitch_setup">
<span class="sig-name descname"><span class="pre">cglitch_setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default_setup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.cglitch_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up sane defaults for clock glitching</p>
<ul class="simple">
<li><p>glitch clk_src = clkgen</p></li>
<li><p>output = clock_xor</p></li>
<li><p>trigger_src = ext_single</p></li>
<li><p>hs2 = glitch</p></li>
<li><p>LP and HP glitch disabled</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.con">
<span class="sig-name descname"><span class="pre">con</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idProduct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bitstream</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prog_speed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000000.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.con" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects to attached chipwhisperer hardware (Lite, Pro, or Husky)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sn</strong> (<em>str</em>) – The serial number of the attached device. Does not need to
be specified unless there are multiple devices attached.</p></li>
<li><p><strong>idProduct</strong> (<em>int</em>) – The product ID of the ChipWhisperer. If None, autodetects product ID. Optional.</p></li>
<li><p><strong>bitstream</strong> (<em>str</em>) – Path to bitstream to program. If None, programs default bitstream. Optional.</p></li>
<li><p><strong>force</strong> (<em>bool</em>) – Force reprogramming of bitstream. If False, only program bitstream if no bitstream
is currently programmed. Optional.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if connection is successful, False otherwise</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 5.5: </span>Added idProduct, bitstream, and force parameters.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.default_setup">
<span class="sig-name descname"><span class="pre">default_setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.default_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up sane capture defaults for this scope</p>
<blockquote>
<div><ul class="simple">
<li><p>25dB gain</p></li>
<li><p>5000 capture samples</p></li>
<li><p>0 sample offset</p></li>
<li><p>rising edge trigger</p></li>
<li><p>7.37MHz clock output on hs2</p></li>
<li><p>4*7.37MHz ADC clock</p></li>
<li><p>tio1 = serial rx</p></li>
<li><p>tio2 = serial tx</p></li>
<li><p>CDC settings change off</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>verbose</strong> (<em>bool</em>) – shows which scope settings have changed. Ignores scope.XADC changes,
except for scope.XADC.status.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.1: </span>Added default setup for OpenADC</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.dis">
<span class="sig-name descname"><span class="pre">dis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.dis" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnects the current scope object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the disconnection was successful, False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.fpga_buildtime">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fpga_buildtime</span></span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.fpga_buildtime" title="Permalink to this definition">¶</a></dt>
<dd><p>When the FPGA bitfile was generated. Husky only.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.get_last_trace">
<span class="sig-name descname"><span class="pre">get_last_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.get_last_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last trace captured with this scope.</p>
<p>Can return traces as floating point values (<code class="code docutils literal notranslate"><span class="pre">as_int=False</span></code>)
or as integers.</p>
<p>Floating point values are scaled and shifted to be between -0.5 and 0.5.</p>
<p>Integer values are raw readings from the ChipWhisperer ADC. The ChipWhisperer-Lite
has a 10-bit ADC, the Nano has an 8-bit ADC, and the Husky can read either
8-bits or 12-bits of ADC data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>as_int</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If False, return trace as a float. Otherwise, return as an int.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Numpy array of the last capture trace.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 5.6.1: </span>Added as_int parameter</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.get_last_trace_segmented">
<span class="sig-name descname"><span class="pre">get_last_trace_segmented</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.get_last_trace_segmented" title="Permalink to this definition">¶</a></dt>
<dd><p>Return last trace assuming it was captued with segmented mode.</p>
<p>NOTE: The length of each returned trace is 1 less sample than requested.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>2-D numpy array of the last captured traces.</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.5: </span>Added segmented capture (requires custom bitstream)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.get_name">
<span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.get_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the name of the attached scope</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>‘ChipWhisperer Lite’ if a Lite, ‘ChipWhisperer Pro’ if a Pro, ‘ChipWhisperer Husky’ if a Husky</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.glitch_disable">
<span class="sig-name descname"><span class="pre">glitch_disable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.glitch_disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Disables glitch and glitch outputs</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.reload_fpga">
<span class="sig-name descname"><span class="pre">reload_fpga</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bitstream</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reconnect</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prog_speed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.reload_fpga" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re)loads a FPGA bitstream (even if already configured).</p>
<p>Will cause a reconnect event, all settings become default again.
If no bitstream specified default is used based on current
configuration settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bitstream</strong> (<em>str</em><em> or </em><em>None</em>) – Path to new bitstream file. Optional, defaults to None</p></li>
<li><p><strong>reconnect</strong> (<em>True</em>) – Whether or not to reconnect to the scope</p></li>
<li><p><strong>prog_speed</strong> (<em>int</em>) – Speed at which to program the FPGA</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.reset_fpga">
<span class="sig-name descname"><span class="pre">reset_fpga</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.reset_fpga" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset Husky FPGA. This causes all FPGA-based settings to return to their default values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.scope_diff">
<span class="sig-name descname"><span class="pre">scope_diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scope_dict1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scope_dict2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.scope_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports differences between two sets of scope settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scope_dict1</strong> – dictionaries of scope settings (obtained
with scope._dict_repr())</p></li>
<li><p><strong>scope_dict2</strong> – dictionaries of scope settings (obtained
with scope._dict_repr())</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.OpenADC.vglitch_setup">
<span class="sig-name descname"><span class="pre">vglitch_setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glitcht</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_setup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.OpenADC.vglitch_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up sane defaults for voltage glitch</p>
<ul class="simple">
<li><p>glitch clk_src = clkgen</p></li>
<li><p>output = glitch_only</p></li>
<li><p>trigger_src = ext_single</p></li>
<li><p>hs2 = clkgen</p></li>
<li><p>LP glitch if glitcht = ‘lp’ or ‘both’</p></li>
<li><p>HP glitch if glitcht = ‘hp’ or ‘both’</p></li>
</ul>
</dd></dl>

</dd></dl>

<section id="scope-gain">
<h3>scope.gain<a class="headerlink" href="#scope-gain" title="Permalink to this heading">¶</a></h3>
<p>Class to control ADC gain</p>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.GainSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GainSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.GainSettings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.GainSettings.db">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">db</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.GainSettings.db" title="Permalink to this definition">¶</a></dt>
<dd><p>The gain of the ChipWhisperer’s low-noise amplifier in dB. Ranges
from -6.5 dB to 56 dB, depending on the amplifier settings.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current gain in dB (float)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the gain level in dB</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if new gain is outside of [-6.5, 56]</p>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># reading and storing</span>
<span class="n">gain_db</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">gain</span><span class="o">.</span><span class="n">db</span>

<span class="c1"># setting</span>
<span class="n">scope</span><span class="o">.</span><span class="n">gain</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.GainSettings.gain">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gain</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.GainSettings.gain" title="Permalink to this definition">¶</a></dt>
<dd><p>The current LNA gain setting.</p>
<p>This gain is a dimensionless number in the range [0, 78]. Higher value
causes higher gain in dB.</p>
<p>Note that this function is unnecessary - the dB gain can be set
directly. This property is only here to help convert old scripts.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current gain setting (int)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the gain</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if gain outside [0, 78]</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.GainSettings.mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mode</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">str</span></em><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.GainSettings.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The current mode of the LNA.</p>
<p>The LNA can operate in two modes: low-gain or high-gain. Generally, the
high-gain setting is better to use. Note that this value will be
automatically updated if the dB gain is set.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current gain mode (“low” or “high”)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the gain mode</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if mode not one of “low” or “high”</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
<section id="scope-adc">
<h3>scope.adc<a class="headerlink" href="#scope-adc" title="Permalink to this heading">¶</a></h3>
<p>Class to control non-gain, non-clock ADC settings</p>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">TriggerSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.basic_mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">basic_mode</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.basic_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of event to use as a trigger.</p>
<p>Only applies to the ADC capture - the glitch module
is always a rising edge trigger.</p>
<dl class="simple">
<dt>There are four possible types of trigger events:</dt><dd><ul class="simple">
<li><p>“low”: triggers when line is low (logic 0)</p></li>
<li><p>“high”: triggers when line is high (logic 1)</p></li>
<li><p>“rising_edge”: triggers when line transitions from low to high</p></li>
<li><p>“falling_edge:” triggers when line transitions from high to low</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This must be set to “rising_edge” if a trigger other than
“basic” is used. The SAD/DecodeIO triggers will not work with any
other setting!</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current trigger mode (one of the 4 above strings)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the trigger mode</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if value is not one of the allowed strings</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.clear_clip_errors">
<span class="sig-name descname"><span class="pre">clear_clip_errors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.clear_clip_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>ADC clipping errors are sticky until manually cleared by calling this.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.clip_errors_disabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clip_errors_disabled</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.clip_errors_disabled" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, ADC clipping is flagged as an error. Disable if you
do not want this error notification.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.decimate">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">decimate</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.decimate" title="Permalink to this definition">¶</a></dt>
<dd><p>The ADC downsampling factor.</p>
<p>This value instructs the ChipWhisperer to only record 1 sample in
every &lt;decimate&gt;. In other words, if this value is set to 10, the
sampling rate is set to 1/10th of the sampling clock.</p>
<p>This setting is helpful for recording very long operations or for
reducing the sampling rate for streaming mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return an integer with the current decimation factor</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the decimation factor</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if the new factor is not positive</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.fifo_fill_mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fifo_fill_mode</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.fifo_fill_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The ADC buffer fill strategy - allows segmented usage for CW-lite and CW-pro.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>THIS REQUIRES NEW FPGA BITSTREAM - NOT YET IN THE PYTHON.</p>
</div>
<p>Only the ‘Normal’ mode is well supported, the other modes can
be used carefully.</p>
<p>For segmenting on CW-Husky, see ‘segments’ instead.</p>
<dl class="simple">
<dt>There are four possible modes:</dt><dd><ul class="simple">
<li><p>“normal”: Trigger line &amp; logic work as expected.</p></li>
<li><dl class="simple">
<dt>“enable”: Capture starts with rising edge, but writing samples</dt><dd><p>is enabled by active-high state of trigger line.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“segment”: Capture starts with rising edge, and writes <cite>trigger.samples</cite></dt><dd><p>to buffer on each rising edge, stopping when the buffer
is full. For this to work adc.samples must be a multiple
of 3 (will be enforced by API).</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The “enable” and “segment” modes requires you to fill
the <strong>full buffer</strong> (~25K on CW-Lite, ~100K on CW-Pro).
This requires you to ensure the physical trigger line will
be high (enable mode) or toggle (segment mode) enough. The
ChipWhisperer hardware will currently stall until the
internal buffer is full, and future commands will fail.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>adc.basic_mode must be set to “rising_edge” if a fill_mode other than
“normal” is used. Bad things happen if not.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current fifo fill mode (one of the 3 above strings)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the fifo fill mode</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if value is not one of the allowed strings</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.fifo_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fifo_state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.fifo_state" title="Permalink to this definition">¶</a></dt>
<dd><p>return the state of the Husky FIFO FSM.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Husky only, for debugging</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.lo_gain_errors_disabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lo_gain_errors_disabled</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.lo_gain_errors_disabled" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, captures which use less than a quarter of the ADC’s
dynamic range flag an error, to indicate that the gain should be
increased. Disable if you do not want this error notification.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.offset">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">offset</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of samples to wait before recording data after seeing a
trigger event.</p>
<p>This offset is useful for long operations. For instance, if an
encryption is 1 million samples long, it’s difficult to capture the
entire power trace, but an offset can be used to skip to the end of
the encryption.</p>
<p>The offset must be a 32 bit unsigned integer.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current offset (integer)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set a new offset</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if offset outside of range [0, 2**32)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.presamples">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">presamples</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.presamples" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of samples to record from before the trigger event.</p>
<p>This setting must be a positive integer, and it cannot be larger than
the number of samples. When streaming mode is enabled, this value is
set to 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current number of presamples</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the number of presamples.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if presamples is outside of range [0, samples]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.samples">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">samples</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of ADC samples to record in a single capture.</p>
<p>The maximum number of samples is hardware-dependent:
- cwlite: 24400
- cw1200: 96000
- cwhusky: 131070</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current number of total samples (integer)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the number of samples to capture</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if number of samples is negative</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.state" title="Permalink to this definition">¶</a></dt>
<dd><p>The current state of the trigger input.</p>
<p>This is a digital value (ie: high or low), which is some combination
of the pins in the triggermux object. Read-only.</p>
<p>Getter: Return the current state (True or False).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.timeout">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">timeout</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of seconds to wait before aborting a capture.</p>
<p>If no trigger event is detected before this time limit is up, the
capture fails and no data is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the number of seconds before a timeout (float)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the timeout in seconds</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.trig_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">trig_count</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.trig_count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of samples that the trigger input was active.</p>
<p>This value indicates how long the trigger was high or low last time
a trace was captured. It is the number of samples where the input was
low (in “low” or “falling edge” modes) or high (in “high” or “rising
edge” modes). Read-only.</p>
<p>This counter is not meaningful if the trigger is still active.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the last trigger duration (integer)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<section id="scope-adc-pro-husky-only">
<h4>scope.adc Pro/Husky Only<a class="headerlink" href="#scope-adc-pro-husky-only" title="Permalink to this heading">¶</a></h4>
<p>The following <code class="code docutils literal notranslate"><span class="pre">scope.adc</span></code> members are only available on ChipWhisperer-Husky, ChipWhisperer-Pro, or both.</p>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">TriggerSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.stream_mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TriggerSettings.</span></span><span class="sig-name descname"><span class="pre">stream_mode</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.stream_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The ChipWhisperer’s streaming status. Only available on CW1200 and CW-Husky.</p>
<p>When stream mode is enabled, the ChipWhisperer sends back ADC data as
soon as it is recorded. In this mode, there is no hardware limit on the
maximum number of samples per trace (although Python may run out of
memory when recording billions of points). However, there is a
maximum streaming data rate, which is approximately 10 Msamp/s.</p>
<p>Note that no pre-trigger samples can be recorded when stream mode
is enabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return True if stream mode is enabled and False otherwise</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Enable or disable stream mode</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.segment_cycles">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TriggerSettings.</span></span><span class="sig-name descname"><span class="pre">segment_cycles</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.segment_cycles" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of clock cycles separating segments.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Supported by CW-Husky only. For segmenting on CW-lite or
CW-pro, see ‘fifo_fill_mode’ instead.</p>
</div>
<p>This setting must be a 20-bit positive integer.</p>
<p>When ‘segments’ is greater than one, set segment_cycles to a non-zero
value to capture a new segment every ‘segment_cycles’ clock cycles
following the initial trigger event. ‘segment_cycle_counter_en’ must
also be set.</p>
<p>Typically, segment_cycles should be much greater than
scope.adc.samples. If they are too close, capture will fail (indicated by
the blinking red lights and scope.adc.errors showing either a
segmenting error or a FIFO over/underflow error).
When presamples = 0, segment_cycles &gt;= samples + 10.
When presamples &gt; 0, segment_cycles &gt;= samples + presamples AND segment_cycles &gt;= samples + 10.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current value of segment_cycles.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set segment_cycles.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if segments is outside of range [0, 2^20-1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.segment_cycle_counter_en">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TriggerSettings.</span></span><span class="sig-name descname"><span class="pre">segment_cycle_counter_en</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.segment_cycle_counter_en" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of clock cycles separating segments.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Supported by CW-Husky only. For segmenting on CW-lite or
CW-pro, see ‘fifo_fill_mode’ instead.</p>
</div>
<p>Set to 0 to capture a new power trace segment every time the target
issues a trigger event.</p>
<p>Set to 1 to capture a new power trace segment every ‘segment_cycles’
clock cycles after a single trigger event.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current value of segment_cycle_counter_en.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set segment_cycles.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.first_error_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TriggerSettings.</span></span><span class="sig-name descname"><span class="pre">first_error_state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.first_error_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the state the FPGA FSM state at the time of the first flagged error. Useful for debugging. Read-only.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Supported by CW-Husky only.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the error flags.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.errors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TriggerSettings.</span></span><span class="sig-name descname"><span class="pre">errors</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.errors" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal error flags (FPGA FIFO over/underflow)</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Supported by CW-Husky only.</p>
</div>
<dl class="simple">
<dt>Error types and their causes:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>‘presample error’: capture trigger occurs before the requested</dt><dd><p>number of presamples have been collected. Reduce
scope.adc.presamples or delay the capture trigger.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘ADC clipped’: gain is too high; reduce it (scope.gain) or disable</dt><dd><p>this error (scope.adc.clip_errors_disabled).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘gain too low error’: gain is “too low” (4 bits or more of the ADC’s</dt><dd><p>dynamic range did not get used); increase it (scope.gain) or
disable this error (scope.adc.lo_gain_errors_disabled).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘invalid downsample setting’: using downsampling (aka decimating) with</dt><dd><p>presamples and multiple segments is not allowed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘segmenting error’: the condition for starting the capture of the next</dt><dd><p>segment came true before the capture of the current segment
completed. Reduce the segment size and/or increase the time
between segments.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘fast FIFO underflow’: shouldn’t occur in isolation without</dt><dd><p>other errors being flagged.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘fast FIFO overflow’: data is coming in fast than it’s being read;</dt><dd><p>reduce scope.clock.adc_freq.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘slow FIFO underflow’: host tried to read more ADC samples than are</dt><dd><p>available.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>‘slow FIFO overflow’: data is coming in faster than it’s being</dt><dd><p>read; reduce scope.clock.adc_freq.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>To fully understand the four different FIFO errors (fast/slow
over/underflows), some background on Husky’s sample storage
architecture is required.  ADC samples are first stored in a “fast”
FIFO which runs at the ADC sampling rate, then moved to a wider and
“slower” FIFO which is read by the host. Overflows or underflows can
occur in either FIFO. Errors can be caused from an illegal
configuration of scope.adc (e.g. too many samples), or attempting to
stream too fast.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the error flags.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Clear error flags.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.segments">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TriggerSettings.</span></span><span class="sig-name descname"><span class="pre">segments</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of sample segments to capture.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Supported by CW-Husky only. For segmenting on CW-lite or
CW-pro, see ‘fifo_fill_mode’ instead.</p>
</div>
<p>This setting must be a 16-bit positive integer.</p>
<p>In normal operation, segments=1.</p>
<p>Multiple segments are useful in two scenarios:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>Capturing only subsections of a power trace, to allow longer</dt><dd><p>effective captures.  After a trigger event, the requested number of
samples is captured every ‘segment_cycles’ clock cycles, ‘segments’
times. Set ‘segment_cycle_counter_en’ to 1 for this segment mode.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Speeding up capture times by capturing ‘segments’ power traces from</dt><dd><p>a single arm + capture event. Here, the requested number of samples
is captured at every trigger event, without having to re-arm and
download trace data between every trigger event. Set
‘segment_cycle_counter_en’ to 0 for this segment mode.</p>
</dd>
</dl>
</li>
</ol>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>when capturing multiple segments with presamples, the total number of samples
per segment must be a multiple of 3. Incorrect sample data will be obtained if this is not
the case.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current number of presamples</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the number of presamples.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if segments is outside of range [1, 2^16-1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.bits_per_sample">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">TriggerSettings.</span></span><span class="sig-name descname"><span class="pre">bits_per_sample</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.TriggerSettings.bits_per_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Bits per ADC sample. Only available on CW-Husky.</p>
<p>Husky has a 12-bit ADC; optionally, we read back only 8 bits per
sample.  This does <em>not</em> allow for more samples to be collected; it
only allows for a faster sampling rate in streaming mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>return the number of bits per sample that will be received.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>set the number of bits per sample to receive.</p>
</dd>
</dl>
</dd></dl>

</div></blockquote>
</section>
</section>
<section id="scope-clock">
<h3>scope.clock<a class="headerlink" href="#scope-clock" title="Permalink to this heading">¶</a></h3>
<section id="scope-clock-lite-pro-only">
<h4>scope.clock (Lite/Pro Only)<a class="headerlink" href="#scope-clock-lite-pro-only" title="Permalink to this heading">¶</a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>ChipWhisperer-Lite/Pro only. See
<a class="reference internal" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock" title="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.clock</span> <span class="pre">(Husky)</span></code></a> for Husky clock documentation.</p>
</div>
<p>Class to control target/ADC clocks. A block diagram of the clock module is shown below:</p>
<blockquote>
<div><a class=""
               data-lightbox="group-4f7ad049-bbd8-4a74-9cf6-b978ac83efb2"
               href="_images/cwlitepro_clock.png"
               title=""
               data-title=""
               
               ><img src="_images/cwlitepro_clock.png"
                     class=""
                     width="100%"
                     height="auto"
                     alt=""/>
                </a><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ClockSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwinfo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_freq">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_freq</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>The current frequency of the ADC clock in Hz. Read-only.</p>
<p>This clock frequency is derived from one of the ADC clock sources as
described in adc_src.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current frequency in Hz (int). May take
up to 0.5s to stabilize after adc_locked is True.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_locked">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_locked</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>The current status of the ADC DCM. Read-only.</p>
<p>To try re-locking the ADC, see reset_adc().</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return whether the ADC DCM is locked (True or False)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_phase">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_phase</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Fine adjustment for the ADC sampling point.</p>
<p>This setting moves the sampling point approximately 5 ns forward or
backward, regardless of the sampling frequency. It may be helpful to
improve the stability of the measurement.</p>
<p>The value of this setting is dimensionless and has a non-linear
effect on the phase adjustment.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current phase setting (integer)
NOTE: This getter is currently broken due to an FPGA bug.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set a new phase offset</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – if offset not in [-32767, 32767] (Husky) or [-255, 255] (others)</p></li>
<li><p><strong>TypeError</strong> – if offset not integer</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_rate">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_rate</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>The current sampling rate of the ADC clock in samples/s. Read-only.</p>
<p>Note that the sampling rate may be less than the clock frequency if
the downsampling factor is greater than 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current sampling rate in samples/s (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.adc_src" title="Permalink to this definition">¶</a></dt>
<dd><p>The clock source for the ADC module.</p>
<p>The ADC can be clocked by one of five possible sources:</p>
<blockquote>
<div><ul class="simple">
<li><p>“clkgen_x1”: CLKGEN output via DCM</p></li>
<li><p>“clkgen_x4”: CLKGEN output via DCM with x4 clk multiplier</p></li>
<li><p>“extclk_x1”: External clock input via DCM</p></li>
<li><p>“extclk_x4”: External clock input via DCM with x4 clk multiplier</p></li>
<li><p>“extclk_dir”: External clock input with no DCM</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current ADC clock source (one of five strings above)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the ADC clock source and reset the ADC DCM to lock it.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if string not in valid settings</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_div">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkgen_div</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_div" title="Permalink to this definition">¶</a></dt>
<dd><p>The divider in the CLKGEN DCM.</p>
<p>This divider must be in the range [1, 256].</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current CLKGEN divider (integer)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set a new CLKGEN divider.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_freq">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkgen_freq</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>The CLKGEN output frequency in Hz.</p>
<p>The CLKGEN module takes the input source and multiplies/divides it to
get a faster or slower clock as desired. Minimum clock in practice
is 3.2MHz.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current calculated CLKGEN output frequency in Hz
(float). Note that this is the theoretical frequency - use the
freq counter to determine the actual output. May take up to 0.5s
to stabilize after clkgen_locked is True.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Attempt to set a new CLKGEN frequency in Hz. When this value is
set, all possible DCM multiply/divide settings are tested to find
which is closest to the desired output speed. If EXTCLK is the
CLKGEN source, the EXTCLK frequency must be properly set for this
to work. Also, both DCMs are reset.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_locked">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkgen_locked</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>The current status of the CLKGEN DCM. Read-only.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return whether the CLKGEN DCM is locked (True or False)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_mul">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkgen_mul</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>The multiplier in the CLKGEN DCM.</p>
<p>This multiplier must be in the range [2, 256].</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current CLKGEN multiplier (integer)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set a new CLKGEN multiplier.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkgen_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.clkgen_src" title="Permalink to this definition">¶</a></dt>
<dd><p>The input source for the CLKGEN DCM.</p>
<p>This DCM can receive input from one of two places:</p>
<ul class="simple">
<li><p>“extclk”: The external clock input</p></li>
<li><p>“system” or “internal”: The system clock (96 MHz)</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current CLKGEN input (either “extclk” or “system”)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the CLKGEN source and reset all the DCMs.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if source is not one of three strings above</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enabled</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether the Xilinx MMCM used to generate the target clock
is powered on or not. In Husky, an external PLL is used instead; this
FPGA PLL is still present but disabled by default because MMCMs are
quite power-hungry.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.extclk_freq">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extclk_freq</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.extclk_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>The input frequency from the EXTCLK source in Hz.</p>
<p>This value is used to help calculate the correct CLKGEN settings to
obtain a desired output frequency when using EXTCLK as CLKGEN input.
It is not a frequency counter - it is only helpful if the EXTCLK
frequency is already known.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the last set EXTCLK frequency in MHz (int)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Update the EXTCLK frequency</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.freq_ctr">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">freq_ctr</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.freq_ctr" title="Permalink to this definition">¶</a></dt>
<dd><p>The current frequency at the frequency counter in Hz. Read-only.</p>
<p>The frequency counter can be used to check the speed of the CLKGEN
output or the EXTCLK input. This value shows the current frequency
reading.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current frequency in Hz (int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.freq_ctr_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">freq_ctr_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.freq_ctr_src" title="Permalink to this definition">¶</a></dt>
<dd><p>The current input to the frequency counter.</p>
<p>There are two possible inputs to the frequency counter:
- “clkgen”: The CLKGEN DCM output
- “extclk”: The external input clock signal</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the frequency counter input (one of the above strings)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the frequency counter source</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if source is not “clkgen” or “extclk”</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.reset_adc">
<span class="sig-name descname"><span class="pre">reset_adc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.reset_adc" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the ADC DCM.</p>
<p>After changing frequencies, the ADC DCM may become unlocked from its
input signal. This function resets the DCM to re-lock it.</p>
<p>If the DCM is still unlocked after calling this function, the clock
may be too fast for the ADC.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.reset_clkgen">
<span class="sig-name descname"><span class="pre">reset_clkgen</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.reset_clkgen" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the CLKGEN DCM.</p>
<p>After changing frequencies or input sources, the CLKGEN DCM may not
be locked. This function resets the DCM to re-lock it.</p>
<p>If the DCM is still unlocked after calling this function, the clock
may be too fast for the CLKGEN module.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.reset_dcms">
<span class="sig-name descname"><span class="pre">reset_dcms</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes._OpenADCInterface.ClockSettings.reset_dcms" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the CLKGEN DCM, then the ADC DCM.</p>
<p>This order is necessary because the ADC may depend on having a locked
clock from the CLKGEN output.</p>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
<section id="scope-clock-husky-only">
<h4>scope.clock (Husky Only)<a class="headerlink" href="#scope-clock-husky-only" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ChipWhispererHuskyClock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fpga_clk_settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmcm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmcm2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_freq">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_freq</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the ADC frequency based on clkgen_freq and adc_mul</p>
<p>Read-only</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_locked">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_locked</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for backwards compatibility with how ADC clocks
are managed on CW-lite and CW-pro.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_mul">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_mul</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a new ADC clock frequency by multiplying this value by clkgen_freq</p>
<p>Must be a positive integer, or 0. If 0, turns the ADC clock off.</p>
<p>adc_freq = adc_mul * clkgen_freq</p>
<p>Note that the value of adc_mul affects how closely clkgen_freq can be matched
to the requested frequency. See clkgen_freq for more information.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>The currently set adc multiplier</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the adc multiplier</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_phase">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_phase</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the phase of the ADC clock relative to the target clock</p>
<p>Positive values delay the ADC clock compared to the target clock
and vice versa.</p>
<p>Negative values are not possible when scope.clock.clkgen_src is
‘extclk’.</p>
<p>Note: The actual phase is only a 6 bit signed value compared to
a 9 bit signed value on the Lite/Pro. This is mapped onto
the same [-255, 255] range, meaning not all phases
between -255 and 255 are possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Gets the current adc_phase</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Sets the adc_phase. Must be in the range [-255, 255]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">adc_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.adc_src" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for backwards compatibility with how ADC clocks
are set on CW-lite and CW-pro.</p>
<p>The ADC can be clocked by one of five possible sources:</p>
<blockquote>
<div><ul class="simple">
<li><p>“clkgen_x1”: CLKGEN output via DCM</p></li>
<li><p>“clkgen_x4”: CLKGEN output via DCM with x4 clk multiplier</p></li>
<li><p>“extclk_x1”: External clock input via DCM</p></li>
<li><p>“extclk_x4”: External clock input via DCM with x4 clk multiplier</p></li>
<li><p>“extclk_dir”: External clock input with no DCM</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current ADC clock source (one of five strings above)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the ADC clock source and reset the ADC DCM to lock it.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if string not in valid settings</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.clear_adc_unlock">
<span class="sig-name descname"><span class="pre">clear_adc_unlock</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.clear_adc_unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this to decorate methods that can cause the PLL to momentarily unlock. Clears
the unlock status and then re-enables it. If PLL lock is regained, then the user will
see the ADC LED turn on for a short time. If the PLL remains unlocked, then the ADC
LED will turn on, flicker off, then turn back on and stay on.
We do this because the ADC LED is sticky (i.e. stays on after an unlock event, even
when the PLL re-locks, until manually cleared).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.clkgen_freq">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkgen_freq</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.clkgen_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>The target clock frequency in Hz.</p>
<p>The PLL takes the input clock frequency and multiplies it/divides to
match as closely as possible to the set clkgen_freq. If set to 0,
turns both the target and ADC clocks off.</p>
<p>Some important notes for setting this value:</p>
<ul class="simple">
<li><p>The minimum output frequency is 500kHz and the maximum is 350MHz</p></li>
<li><dl class="simple">
<dt>The ADC clock output frequency (clkgen_freq * adc_mul) must be</dt><dd><p>below 200MHz. Therefore, if you want to use
a clkgen_freq above 200MHz, you must set adc_mul=0</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The accuracy of the actual clkgen_freq will depend</dt><dd><p>on adc_mul, as the output divisor for the clkgen_freq must divide
cleanly by adc_mul. For example, if you try to use a clkgen_freq
of 7.37MHz and and adc_mul of 16, the closest valid clkgen_freq
will be 7.5MHz.</p>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the calculated target clock frequency in Hz</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Attempt to set a new target clock frequency in Hz.
This also blindly clears extclk_error if there is one, but it only
assumes, and does not verify, that the frequency has been updated
to the correct value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.clkgen_locked">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkgen_locked</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.clkgen_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the Husky PLL is locked</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.clkgen_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkgen_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.clkgen_src" title="Permalink to this definition">¶</a></dt>
<dd><p>The input for the Husky’s PLL, which generates clocks
for the target and the ADC.</p>
<p>The PLL can receive input from two places:</p>
<ul class="simple">
<li><p>“system” or “internal”: An onboard crystal</p></li>
<li><p>“extclk”: An external clock (e.g. generated by the target).</p></li>
</ul>
<p>When clkgen_src is set to “extclk”, the external clock frequency is
measured to set the ADC clock accordingly. If the external clock
frequency is later modified, then clkgen_src must be re-set to “extclk”
in order for the frequency change to be recognized. Otherwise, the ADC
sampling clock will remain tied to the <em>previous</em> external clock
frequency.</p>
<p>A variant on “extclk” is “extclk_aux_io”, when the external clock is
supplied on the AUX I/O MCX instead of the HS1 pin (scope.io.aux_io_mcx
must be set to “high_z” in this case).</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current PLL input (“system”, “extclk” or “extclk_aux_io”)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the CLKGEN source</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if source is not one of the above</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.extclk_error">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extclk_error</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.extclk_error" title="Permalink to this definition">¶</a></dt>
<dd><p>When the external clock is used, a change in clock frequency
exceeding extclk_error will flag an error. The purpose of this is to
remind you that you need to set scope.clock.clkgen_freq to the
frequency of your external clock.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the external clock monitor has flagged an error.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Clear the error.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.extclk_monitor_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extclk_monitor_enabled</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.extclk_monitor_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>When enabled, any change in the external clock frequency input
exceeding the amount set in self.extclk_tolerance will trigger an
error.</p>
<p>When using an external clock to drive ChipWhisperer (i.e.
self.clkgen_src == ‘extclk’), Husky must know the frequency of that
clock (by setting scope.clock.clkgen_freq). This clock monitor is a
convenience to flag when the frequency changes without Husky being
informed of that change.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the external clock monitor is enabled.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Enable/disable the external clock monitor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.extclk_tolerance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extclk_tolerance</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.extclk_tolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Tolerance for external clock frequency change, measured in Hz. If
the difference between consecutive measurements exceeds this, an error
is flagged. Defaults to ~100 Hz.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Get the frequency change tolerance [Hz].</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the frequency change tolerance [Hz].</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.fpga_vco_freq">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fpga_vco_freq</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.fpga_vco_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the FPGA clock glitch PLL’s VCO frequency.</p>
<p>Affects <a class="reference internal" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.phase_shift_steps" title="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.phase_shift_steps"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.glitch.phase_shift_steps</span></code></a></p>
<p>Allowed range: 600 - 1200 MHz.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Calculate vco from last set value [Hz]</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the vco frequency [Hz]</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – set vco out of valid range</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.freq_ctr">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">freq_ctr</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.freq_ctr" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the frequency of the external input clock</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.freq_ctr_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">freq_ctr_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyClock.ChipWhispererHuskyClock.freq_ctr_src" title="Permalink to this definition">¶</a></dt>
<dd><p>The current input to the frequency counter.</p>
<p>There are two possible inputs to the frequency counter:
- “clkgen”: The CLKGEN DCM output
- “extclk”: The external input clock signal</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the frequency counter input (one of the above strings)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the frequency counter source</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if source is not “pll” or “extclk”</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
</section>
<section id="scope-io">
<h3>scope.io<a class="headerlink" href="#scope-io" title="Permalink to this heading">¶</a></h3>
<p>Module to control IO pins</p>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GPIOSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cwextra</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.aux_io_mcx">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aux_io_mcx</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.aux_io_mcx" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the function of the AUX I/O MCX on Husky.</p>
<p>Options:</p>
<ul class="simple">
<li><p>“high_z”: input: to use as a trigger (scope.trigger.triggers = ‘aux’) or clock (scope.clock.clkgen_src = ‘extclk_aux_io’).</p></li>
<li><p>“hs2”: output: provide the same clock that’s on HS2.</p></li>
</ul>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.cdc_settings">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cdc_settings</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.cdc_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Check or set whether USART settings can be changed via the USB CDC connection</p>
<p>i.e. whether you can change USART settings (baud rate, 8n1) via a serial client like PuTTY</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>An array of length four for four possible CDC serial ports (though only one is used)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Can set either via an integer (which sets both ports) or an array of length 4 (which sets each port)</p>
</dd>
</dl>
<p>Returns None if using firmware before the CDC port was added</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.extclk_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extclk_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.extclk_src" title="Permalink to this definition">¶</a></dt>
<dd><p>The clock signal being used as input for EXTCLK.</p>
<p>Currently, this can only be HS1, which is the clock from the target.
As such, this value is read-only.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.glitch_hp">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">glitch_hp</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.glitch_hp" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the high-power crowbar MOSFET is enabled.</p>
<p>The glitch output is an SMA-connected output line that is normally
connected to a target’s power rails. If this setting is enabled, a
high-powered MOSFET shorts the power-rail to ground when the glitch
module’s output is active.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Use with caution - ensure that the glitch module is properly
configured before enabling this setting, as it is possible to
permanently damage hardware with this output.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return True if enabled or False if disabled</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Turn the high-power MOSFET on or off</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.glitch_lp">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">glitch_lp</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.glitch_lp" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the low-power crowbar MOSFET is enabled.</p>
<p>This is the low-power version of glitch_hp - see that documentation
for more details.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Use with caution - ensure that the glitch module is properly
configured before enabling this setting, as it is possible to
permanently damage hardware with this output.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.glitch_trig_mcx">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">glitch_trig_mcx</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.glitch_trig_mcx" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the function of the Trigger/Glitch Out MCX on Husky.
Options:</p>
<ul class="simple">
<li><p>“glitch”: glitch output (clock or voltage glitch signal, as defined by scope.glitch settings)</p></li>
<li><p>“trigger”: internal trigger signal (as defined by scope.trigger)</p></li>
<li><p>“inverted [glitch | trigger]”: inverted glitch or trigger signal</p></li>
</ul>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.hs2">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hs2</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.hs2" title="Permalink to this definition">¶</a></dt>
<dd><p>The clock signal routed to the HS2 high speed output pin.</p>
<dl class="simple">
<dt>Allowed clock signals are:</dt><dd><ul class="simple">
<li><p>“clkgen”: The output from the CLKGEN module</p></li>
<li><p>“glitch”: The output from the glitch module</p></li>
<li><p>“disabled” / None: No clock; output driven low</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return one of “clkgen”, “glitch”, or “disabled”</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the clock to be output on HS2.</p>
</dd>
</dl>
<p>Raises:
ValueError: if new value not listed above</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.miso_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">miso_state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.miso_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the logic level of the MISO pin. Supported by Husky only.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.mosi_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mosi_state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.mosi_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the logic level of the MOSI pin. Supported by Husky only.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.nrst">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nrst</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.nrst" title="Permalink to this definition">¶</a></dt>
<dd><p>The state of the NRST pin.</p>
<p>See pdic for more information.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.nrst_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nrst_state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.nrst_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the logic level of the nRST pin. Supported by Husky only.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.pdic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pdic</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.pdic" title="Permalink to this definition">¶</a></dt>
<dd><p>The function of the PDIC pin output pin.</p>
<dl class="simple">
<dt>This is a GPIO pin. The following values are allowed:</dt><dd><ul class="simple">
<li><p>“high” / True: logic 1</p></li>
<li><p>“low” / False: logic 0</p></li>
<li><p>“disabled” / “default” / “high_z” / None: undriven</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return one of “high”, “low”, or “high_z”. This shows how ChipWhisperer
is driving this pin; it does not show its actual logic level.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the pin’s state</p>
</dd>
</dl>
<p>Raises:
ValueError: if new state not listed above</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.pdic_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pdic_state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.pdic_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the logic level of the PDIC pin. Supported by Husky only.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.pdid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pdid</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.pdid" title="Permalink to this definition">¶</a></dt>
<dd><p>The state of the PDID pin.</p>
<p>See pdic for more information.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.pdid_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pdid_state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.pdid_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the logic level of the PDID pin. Supported by Husky only.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.sck_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sck_state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.sck_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the logic level of the SCK pin. Supported by Husky only.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.target_pwr">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">target_pwr</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.target_pwr" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the target board is powered by the ChipWhisperer.</p>
<p>If True, the ChipWhisperer is currently supplying power to the target
board; if False, it is not. This setting can be used to cycle power to
the target or to help program it.</p>
<p>If the target board is powered through an external supply, this setting
may have no effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current power state of the target (True or False)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Turn the target power on or off.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio1">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tio1</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio1" title="Permalink to this definition">¶</a></dt>
<dd><p>The function of the Target IO1 pin.</p>
<dl class="simple">
<dt>TIO1 can be used for the following functions:</dt><dd><ul class="simple">
<li><p>“serial_rx”: UART input</p></li>
<li><p>“serial_tx”: UART output</p></li>
<li><p>“high_z” / None: High impedance input</p></li>
<li><p>“gpio_low” / False: Driven output: logic 0</p></li>
<li><p>“gpio_high” / True: Driven output: logic 1</p></li>
<li><p>“gpio_disabled”: Driven output: no effect</p></li>
</ul>
</dd>
</dl>
<p>Default value is “serial_rx”.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return one of the above strings. This shows how ChipWhisperer is
driving this pin; it does not show its actual logic level. Use
scope.io.tio_states to see the actual logic level.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the Target IO1 mode.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if new value is not one of the above modes</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio2">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tio2</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio2" title="Permalink to this definition">¶</a></dt>
<dd><p>The function of the Target IO2 pin.</p>
<dl class="simple">
<dt>TIO2 can be used for the following functions:</dt><dd><ul class="simple">
<li><p>“serial_rx”: UART input</p></li>
<li><p>“serial_tx”: UART output</p></li>
<li><p>“high_z” / None: High impedance input</p></li>
<li><p>“gpio_low” / False: Driven output: logic 0</p></li>
<li><p>“gpio_high” / True: Driven output: logic 1</p></li>
<li><p>“gpio_disabled”: Driven output: no effect</p></li>
</ul>
</dd>
</dl>
<p>Default value is “serial_tx”.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return one of the above strings. This shows how ChipWhisperer is
driving this pin; it does not show its actual logic level. Use
scope.io.tio_states to see the actual logic level.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the Target IO2 mode.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if new value is not one of the above modes</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio3">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tio3</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio3" title="Permalink to this definition">¶</a></dt>
<dd><p>The function of the Target IO3 pin.</p>
<dl class="simple">
<dt>TIO3 can be used for the following functions:</dt><dd><ul class="simple">
<li><p>“serial_rx”: UART input</p></li>
<li><p>“serial_tx”: UART output</p></li>
<li><p>“serial_tx_rx”: UART 1-wire I/O (for smartcards)</p></li>
<li><p>“high_z” / None: High impedance input</p></li>
<li><p>“gpio_low” / False: Driven output: logic 0</p></li>
<li><p>“gpio_high” / True: Driven output: logic 1</p></li>
<li><p>“gpio_disabled”: Driven output: no effect</p></li>
</ul>
</dd>
</dl>
<p>Default value is “high_z”.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return one of the above strings. This shows how ChipWhisperer is
driving this pin; it does not show its actual logic level. Use
scope.io.tio_states to see the actual logic level.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the Target IO3 mode.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if new value is not one of the above modes</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio4">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tio4</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio4" title="Permalink to this definition">¶</a></dt>
<dd><p>The function of the Target IO4 pin.</p>
<dl class="simple">
<dt>TIO4 can be used for the following functions:</dt><dd><ul class="simple">
<li><p>“serial_tx”: UART output</p></li>
<li><p>“high_z” / None: High impedance input</p></li>
<li><p>“gpio_low” / False: Driven output: logic 0</p></li>
<li><p>“gpio_high” / True: Driven output: logic 1</p></li>
<li><p>“gpio_disabled”: Driven output: no effect</p></li>
</ul>
</dd>
</dl>
<p>Default value is “high_z”. Typically, this pin is used as a trigger
input.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return one of the above strings. This shows how ChipWhisperer is
driving this pin; it does not show its actual logic level. Use
scope.io.tio_states to see the actual logic level.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the Target IO4 mode</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if new value is not one of the above modes</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tio_states</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.tio_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the logic level of the TIO pins (1-4) and
returns them as a tuple of the logic levels.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>ChipWhisperer firmware before release 5.2.1 does not support
reading the TIO pins!</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Read TIO states</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple of 1’s and 0’s representing the logic levels
of each TIO pin</p>
</dd>
</dl>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.3: </span>Add documented interface for the old method of reading TIO pins</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.vglitch_reset">
<span class="sig-name descname"><span class="pre">vglitch_reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delay</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.GPIOSettings.vglitch_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets scope.io.glitch_hp and scope.io.glitch_lp to False, waits ‘delay’
seconds, then returns scope.io.glitch_hp and scope.io.glitch_lp to
their original settings.</p>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
<section id="scope-trigger">
<h3>scope.trigger<a class="headerlink" href="#scope-trigger" title="Permalink to this heading">¶</a></h3>
<p>Basic trigger control module</p>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.TriggerSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">TriggerSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cwextra</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.TriggerSettings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.TriggerSettings.module">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">module</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.TriggerSettings.module" title="Permalink to this definition">¶</a></dt>
<dd><p>The trigger module in use.</p>
<p>The trigger modules available depend on the hardware. On the CWLite,
only the basic trigger module can be used; on the CW1200, the serial
data and SAD triggers are available too.</p>
<dl class="simple">
<dt>Available trigger modules:</dt><dd><ul class="simple">
<li><p>‘basic’: Trigger on a logic level or edge</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns ‘basic’</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.TriggerSettings.triggers">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">triggers</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.TriggerSettings.triggers" title="Permalink to this definition">¶</a></dt>
<dd><p>The logical input into the trigger module.</p>
<p>The trigger module uses some combination of the scope’s I/O pins to
produce a single value, which it uses for edge/level detection or UART
triggers. This trigger output can combine 5 pins using one of 3
different boolean operations. N/A for ‘trace’ trigger module (see
scope.trace.trace_mode for how to connect trace pins.)</p>
<dl class="simple">
<dt>Pins:</dt><dd><ul class="simple">
<li><p>tio1-4: Target I/O pins 1-4. Note that these pins can be in any mode.</p></li>
<li><p>nRST: Target I/O pin nRST. Note that these pins can be in any mode.</p></li>
<li><p>sma: An auxiliary SMA input, if available (only on CW1200)</p></li>
</ul>
</dd>
<dt>Boolean operations:</dt><dd><ul class="simple">
<li><p>OR: True if any inputs are True; False if none are</p></li>
<li><p>AND: True if all inputs are True; False if any are not</p></li>
<li><p>NAND: False if all inputs are True; True if any are not</p></li>
</ul>
</dd>
</dl>
<p>Note that only one boolean operation can be used over all input pins.</p>
<dl class="simple">
<dt>Examples of acceptable trigger inputs:</dt><dd><ul class="simple">
<li><p>“tio1”</p></li>
<li><p>“tio3 OR tio4”</p></li>
<li><p>“tio1 NAND tio2 NAND sma”</p></li>
<li><p>“nrst”</p></li>
</ul>
</dd>
<dt>Examples of unallowed trigger inputs:</dt><dd><ul class="simple">
<li><p>“tio1 tio2”</p></li>
<li><p>“tio1 AND tio2 OR tio3”</p></li>
<li><p>“tio1 OR tio1”</p></li>
<li><p>“tio1 XOR tio2”</p></li>
<li><p>“serial-tx”</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return a string describing the trigger mode (see examples)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the trigger mode using a string like the ones above</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if string cannot be converted to a legal mode</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<section id="scope-trigger-pro-only">
<h4>scope.trigger (Pro Only)<a class="headerlink" href="#scope-trigger-pro-only" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.ProTrigger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ProTrigger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cwextra</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.ProTrigger" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.ProTrigger.aux_out">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aux_out</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.ProTrigger.aux_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls AUX out on the CWPro</p>
<p>CWPro only</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns True for ‘trigger’, ‘glitch’ for ‘glitch’, ‘clock’ for ‘clock’ or False for no output.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set False or 0 to disable, True or <code class="code docutils literal notranslate"><span class="pre">'trigger'</span></code> for trig_out,
<code class="code docutils literal notranslate"><span class="pre">'glitch'</span></code> for glitch out, or <code class="code docutils literal notranslate"><span class="pre">'clock'</span></code> for clock_out</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.ProTrigger.module">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">module</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.ProTrigger.module" title="Permalink to this definition">¶</a></dt>
<dd><p>The trigger module in use.</p>
<p>The trigger modules available depend on the hardware. On the CWLite,
only the basic trigger module can be used; on the CW1200, the serial
data and SAD triggers are available too.</p>
<dl class="simple">
<dt>Available trigger modules:</dt><dd><ul class="simple">
<li><p>‘basic’: Trigger on a logic level or edge</p></li>
<li><p>‘SAD’:   Trigger from SAD module (CWPro only)</p></li>
<li><p>‘DECODEIO’: Trigger from decode_IO module (CWPro only)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the active trigger module</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Sets the active trigger module</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – module isn’t one of the available strings</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
<section id="scope-trigger-husky-only">
<h4>scope.trigger (Husky Only)<a class="headerlink" href="#scope-trigger-husky-only" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HuskyTrigger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cwextra</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Husky trigger object.
Communicates with all the trigger modules inside CW-Husky.
Usage depends on the active trigger module.</p>
<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger.edges">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">edges</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>For triggering on edge counts, when <code class="code docutils literal notranslate"><span class="pre">scope.trigger.module</span> <span class="pre">=</span> <span class="pre">'edge_counter'</span></code>.</p>
<p>Sets the number of rising+falling edges on <code class="code docutils literal notranslate"><span class="pre">scope.trigger.triggers</span></code> that
need to be seen for a trigger to be issued.</p>
<p>Edges are sampled by the ADC sampling clock (<code class="code docutils literal notranslate"><span class="pre">scope.clock.adc_freq</span></code>), so
ensure that scope.trigger.triggers does not change faster than what can
be seen by that clock.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>val</strong> (<em>int</em>) – number of edges, non-zero 16-bit integer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger.edges_seen">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">edges_seen</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger.edges_seen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of edges seen.</p>
<p>Under normal operation this should
be the same as <code class="code docutils literal notranslate"><span class="pre">scope.trigger.edges</span></code>. When trigger generation failed, Can
be useful to understand why. Resets upon <code class="code docutils literal notranslate"><span class="pre">scope.arm()</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger.level">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">level</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger.level" title="Permalink to this definition">¶</a></dt>
<dd><p>For triggering on ADC sample exceeding a treshold,
when scope.trigger.module = ‘ADC’.</p>
<p>Sets the trigger threshold, in the range [-0.5, 0.5].</p>
<p>If positive, triggers when the ADC sample exceeds this setting;
if negative, triggers when the ADC sample is below this setting.</p>
<p>Only a single trigger is issued (i.e. multiple samples exceeding
the threshold do not each generate a trigger; cannot be used in
conjunction with segmented capture).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger.module">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">module</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererExtra.HuskyTrigger.module" title="Permalink to this definition">¶</a></dt>
<dd><p>The trigger module in use.</p>
<p>The trigger modules available depend on the hardware. On the CWLite,
only the basic trigger module can be used; on the CW1200, the serial
data and SAD triggers are available too.</p>
<dl class="simple">
<dt>Available trigger modules:</dt><dd><ul class="simple">
<li><p>‘basic’:        Trigger on a logic level or edge</p></li>
<li><p>‘ADC’:          Trigger on ADC sample exceeding a threshold</p></li>
<li><p>‘SAD’:          Trigger from SAD module</p></li>
<li><p>‘UART’:         Trigger from UART module</p></li>
<li><p>‘edge_counter’: Trigger after a number of rising/falling edges</p></li>
<li><p>‘trace’:        Trigger from TraceWhisperer</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the active trigger module</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Sets the active trigger module</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – module isn’t one of the available strings</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
</section>
<section id="scope-glitch">
<h3>scope.glitch<a class="headerlink" href="#scope-glitch" title="Permalink to this heading">¶</a></h3>
<p>Module to control glitching. A block diagram of the module is shown below:</p>
<blockquote>
<div><blockquote>
<div><a class=""
               data-lightbox="group-4ff662db-b136-4dbd-8f20-ef904451fef0"
               href="_images/cwlitepro_glitch.png"
               title=""
               data-title=""
               
               ><img src="_images/cwlitepro_glitch.png"
                     class=""
                     width="100%"
                     height="auto"
                     alt=""/>
                </a></div></blockquote>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GlitchSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cwglitch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.arm_timing">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">arm_timing</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.arm_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>When to arm the glitch in single-shot mode.</p>
<p>If the glitch module is in “ext_single” trigger mode, it must be armed
when the scope is armed. There are two timings for this event:</p>
<blockquote>
<div><ul class="simple">
<li><p>“no_glitch”: The glitch module is not armed. Gives a moderate speedup to capture.</p></li>
<li><p>“before_scope”: The glitch module is armed first.</p></li>
<li><p>“after_scope”: The scope is armed first. This is the default.</p></li>
</ul>
</div></blockquote>
<p>This setting may be helpful if trigger events are happening very early.</p>
<p>If the glitch module is not in external trigger single-shot mode, this
setting has no effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current arm timing (“before_scope” or “after_scope”)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the arm timing</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if value not listed above</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.clk_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clk_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.clk_src" title="Permalink to this definition">¶</a></dt>
<dd><p>The clock signal that the glitch DCM is using as input.</p>
<dl class="simple">
<dt>This DCM can be clocked from three different sources:</dt><dd><ul class="simple">
<li><p>“target”: The HS1 clock from the target device (can also be AUX clock for Husky)</p></li>
<li><p>“clkgen”: The CLKGEN DCM output (N/A for Husky)</p></li>
<li><p>“pll”: Husky’s on-board PLL clock (Husky only)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the clock signal currently in use</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the glitch clock source</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – New value not one of “target”, “clkgen” or “pll”</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.ext_offset">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ext_offset</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.ext_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>How long the glitch module waits between a trigger and a glitch.</p>
<p>After the glitch module is triggered, it waits for a number of clock
cycles before generating glitch pulses. This delay allows the glitch to
be inserted at a precise moment during the target’s execution to glitch
specific instructions.</p>
<p>For CW-Husky when scope.glitch.num_glitches &gt; 1, this parameter is a
list with scope.glitch.num_glitches elements, each element
representing the ext_offset value for the corresponding glitch,
relative to the previous glitch. If ext_offset[i] = j, glitch i will
be issued 2+j cycles after the start of glitch i-1.</p>
<p>For CW-Lite/Pro, scope.glitch.num_glitches is not supported so this is
a simply an integer.</p>
<p>Has no effect when trigger_src = ‘manual’ or ‘continuous’.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible to get more precise offsets by clocking the
glitch module faster than the target board.</p>
</div>
<p>This offset must be in the range [0, 2**32).</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current external trigger offset(s). For CW-lite/pro
or when num_glitches=1, this is an integer (for backwards
compatibility).  Otherwise, it is a list of integers.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the external trigger offset(s). Integer for CW-lite/pro,
list of integers for Husky.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>TypeError</strong> – if offset not an integer, or list of integers for Husky</p></li>
<li><p><strong>ValueError</strong> – if any offset outside of range [0, 2**32)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.manual_trigger">
<span class="sig-name descname"><span class="pre">manual_trigger</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.manual_trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually trigger the glitch output.</p>
<p>This trigger is most useful in Manual trigger mode, where this is the
only way to cause a glitch.</p>
<p>Note that for ChipWhisperer-Husky, this method will only cause a glitch
in manual mode, while on the Lite/Pro, this method will always insert a glitch.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.offset">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">offset</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>The offset from a rising clock edge to a glitch pulse rising edge.</p>
<p>For CW-Husky, offset is expressed as the number of phase shift steps.
Minimum offset is obtained at 0 (rising edge of glitch aligned with
rising edge of glitch source clock). At
scope.glitch.phase_shift_steps/2, the glitch rising edge is aligned
with the glitch source clock falling edge. Negative values are
allowed, but -x is equivalent to scope.glitch.phase_shift_steps-x. The
setting rolls over (+x is equivalent to
scope.glitch.phase_shift_steps+x). Run the notebook in
jupyter/demos/husky_glitch.ipynb to visualize glitch settings.</p>
<p>For other capture hardware (CW-lite, CW-pro), offset is expressed
as a percentage of one period.
A pulse may begin anywhere from -49.8% to 49.8% away from a rising
edge, allowing glitches to be swept over the entire clock cycle.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>very large negative offset &lt;-45 may result in double glitches
(CW-lite/pro only).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return an int (Husky) or float (CW-lite/pro) with the current
glitch offset.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the glitch offset. For CW-lite/pro, the new value is
rounded to the nearest possible offset.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>UserWarning</strong> – value outside range [-50, 50] (value is rounded)
    (CW-lite/pro only)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.offset_fine">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">offset_fine</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.offset_fine" title="Permalink to this definition">¶</a></dt>
<dd><p>The fine adjustment value on the glitch offset. N/A for Husky.</p>
<p>This is a dimensionless number that makes small adjustments to the
glitch pulses’ offset. Valid range is [-255, 255].</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This value is write-only. Reads will always return 0.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns 0</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Update the glitch fine offset</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>TypeError</strong> – if offset not an integer</p></li>
<li><p><strong>ValueError</strong> – if offset is outside of [-255, 255]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.output">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.output" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of output produced by the glitch module.</p>
<p>There are 5 ways that the glitch module can combine the clock with its
glitch pulses:</p>
<blockquote>
<div><ul class="simple">
<li><p>“clock_only”: Output only the original input clock.</p></li>
<li><p>“glitch_only”: Output only the glitch pulses - do not use the clock.</p></li>
<li><p>“clock_or”: Output is high if either the clock or glitch are high.</p></li>
<li><p>“clock_xor”: Output is high if clock and glitch are different.</p></li>
<li><p>“enable_only”: Output is high for glitch.repeat cycles.</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>Some of these settings are only useful in certain scenarios:</dt><dd><ul class="simple">
<li><p>Clock glitching: “clock_or” or “clock_xor”</p></li>
<li><p>Voltage glitching: “glitch_only” or “enable_only”</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current glitch output mode (one of above strings)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the glitch output mode.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if value not in above strings</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.readStatus">
<span class="sig-name descname"><span class="pre">readStatus</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.readStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the status of the two glitch DCMs.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>A tuple with 4 elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="n">phase1</span><span class="p">:</span> <span class="n">Phase</span> <span class="n">shift</span> <span class="n">of</span> <span class="n">DCM1</span> <span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="n">A</span> <span class="k">for</span> <span class="n">Husky</span><span class="p">),</span>
<span class="o">*</span> <span class="n">phase2</span><span class="p">:</span> <span class="n">Phase</span> <span class="n">shift</span> <span class="n">of</span> <span class="n">DCM2</span> <span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="n">A</span> <span class="k">for</span> <span class="n">Husky</span><span class="p">),</span>
<span class="o">*</span> <span class="n">lock1</span><span class="p">:</span> <span class="n">Whether</span> <span class="n">DCM1</span> <span class="ow">is</span> <span class="n">locked</span><span class="p">,</span>
<span class="o">*</span> <span class="n">lock2</span><span class="p">:</span> <span class="n">Whether</span> <span class="n">DCM2</span> <span class="ow">is</span> <span class="n">locked</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.repeat">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">repeat</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of glitch pulses to generate per trigger.</p>
<p>When the glitch module is triggered, it produces a number of pulses
that can be combined with the clock signal. This setting allows for
the glitch module to produce stronger glitches (especially during
voltage glitching).</p>
<p>For CW-Husky when scope.glitch.num_glitches &gt; 1, this parameter is a
list with scope.glitch.num_glitches elements, each element
representing the repeat value for the corresponding glitch. The
maximum legal value for repeat[i] is ext_offset[i+1]+1. If an
illegal value is specified, the glitch output may be held high for
up to 8192 cycles.</p>
<p>For CW-Lite/Pro, scope.glitch.num_glitches is not supported so this is
a simply an integer.</p>
<p>Has no effect when trigger_src = ‘continuous’.</p>
<p>Repeat counter must be in the range [1, 8192].</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current repeat value. For CW-lite/pro or when
num_glitches=1, this is an integer (for backwards compatibility).
Otherwise, it is a list of integers.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the repeat counter. Integer for CW-lite/pro, list of
integers for Husky.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>TypeError</strong> – if value not an integer, or list of integers for Husky</p></li>
<li><p><strong>ValueError</strong> – if any value outside [1, 8192]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.resetDCMs">
<span class="sig-name descname"><span class="pre">resetDCMs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keepPhase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.resetDCMs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the two glitch DCMs.</p>
<p>This is automatically run after changing the glitch width or offset,
so this function is typically not necessary.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">state</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.state" title="Permalink to this definition">¶</a></dt>
<dd><p>Glitch FSM state. CW-Husky only. For debug.
Writing any value resets the FSM to its idle state.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.trigger_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">trigger_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.trigger_src" title="Permalink to this definition">¶</a></dt>
<dd><p>The trigger signal for the glitch pulses.</p>
<dl>
<dt>The glitch module can use four different types of triggers:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>“continuous”: Constantly trigger glitches. The following</dt><dd><p>scope.glitch parameters have no bearing in this mode: ext_offset,
repeat, num_glitches.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“manual”: Only trigger glitches by calling <code class="code docutils literal notranslate"><span class="pre">manual_trigger()</span></code>. The</dt><dd><p>following scope.glitch parameters have no bearing in this mode:
ext_offset, num_glitches. In this mode, calling <code class="code docutils literal notranslate"><span class="pre">scope.arm()</span></code> will
trigger a glitch as well.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“ext_single”: Use the trigger module. Once the scope is armed, one</dt><dd><p>set of glitch events is emitted when the trigger condition is
satisfied. Subsequent trigger conditions are ignored unless the
scope is re-armed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“ext_continuous”: Use the trigger module. A set of glitch events is</dt><dd><p>emitted each time the trigger condition is satisfied, whether or
not the scope is armed.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>calling <code class="code docutils literal notranslate"><span class="pre">scope.arm()</span></code> in manual gitch mode will cause a glitch to trigger.</p>
</div>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current trigger source.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the trigger source.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – value not listed above.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.width">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">width</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The width of a single glitch pulse.</p>
<p>For CW-Husky, width is expressed as the number of phase shift steps.
Minimum width is obtained at 0. Maximum width is obtained at
scope.glitch.phase_shift_steps/2. Negative values are allowed, but -x
is equivalent to scope.glitch.phase_shift_steps-x. The setting rolls
over (+x is equivalent to scope.glitch.phase_shift_steps+x). Run the
notebook in jupyter/demos/husky_glitch.ipynb to visualize glitch
settings.</p>
<p>For other capture hardware (CW-lite, CW-pro), width is expressed as a
percentage of one period. One pulse can range from -49.8% to roughly
49.8% of a period. The system may not be reliable at 0%. Note that
negative widths are allowed; these act as if they are positive widths
on the other half of the clock cycle.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return an int (Husky) or float (others) with the current
glitch width.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Update the glitch pulse width. For CW-lite/pro, the value is
adjusted to the closest possible glitch width.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>UserWarning</strong> – Width outside of [-49.8, 49.8]. The value is rounded
    to one of these. (CW-lite/pro only)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.width_fine">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">width_fine</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.width_fine" title="Permalink to this definition">¶</a></dt>
<dd><p>The fine adjustment value on the glitch width. N/A for Husky.</p>
<p>This is a dimensionless number that makes small adjustments to the
glitch pulses’ width. Valid range is [-255, 255].</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This value is write-only. Reads will always return 0.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns 0</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Update the glitch fine width</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>TypeError</strong> – offset not an integer</p></li>
<li><p><strong>ValueError</strong> – offset is outside of [-255, 255]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
<section id="scope-glitch-husky-only">
<h4>scope.glitch (Husky Only)<a class="headerlink" href="#scope-glitch-husky-only" title="Permalink to this heading">¶</a></h4>
<p>The following attributes are only available on, or differ substantially on the ChipWhisperer-Husky</p>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GlitchSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cwglitch</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.enabled">
<span class="sig-prename descclassname"><span class="pre">GlitchSettings.</span></span><span class="sig-name descname"><span class="pre">enabled</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Husky only. Whether the Xilinx MMCMs used to generate glitches are
powered on or not. 7-series MMCMs are power hungry and are estimated
to consume half of the FPGA’s power. If you run into temperature
issues and don’t require glitching, you can power down these MMCMs.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">GlitchSettings.</span></span><span class="sig-name descname"><span class="pre">width</span></span></dt>
<dd><p>The width of a single glitch pulse.</p>
<p>For CW-Husky, width is expressed as the number of phase shift steps.
Minimum width is obtained at 0. Maximum width is obtained at
scope.glitch.phase_shift_steps/2. Negative values are allowed, but -x
is equivalent to scope.glitch.phase_shift_steps-x. The setting rolls
over (+x is equivalent to scope.glitch.phase_shift_steps+x). Run the
notebook in jupyter/demos/husky_glitch.ipynb to visualize glitch
settings.</p>
<p>For other capture hardware (CW-lite, CW-pro), width is expressed as a
percentage of one period. One pulse can range from -49.8% to roughly
49.8% of a period. The system may not be reliable at 0%. Note that
negative widths are allowed; these act as if they are positive widths
on the other half of the clock cycle.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return an int (Husky) or float (others) with the current
glitch width.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Update the glitch pulse width. For CW-lite/pro, the value is
adjusted to the closest possible glitch width.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>UserWarning</strong> – Width outside of [-49.8, 49.8]. The value is rounded
    to one of these. (CW-lite/pro only)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">GlitchSettings.</span></span><span class="sig-name descname"><span class="pre">offset</span></span></dt>
<dd><p>The offset from a rising clock edge to a glitch pulse rising edge.</p>
<p>For CW-Husky, offset is expressed as the number of phase shift steps.
Minimum offset is obtained at 0 (rising edge of glitch aligned with
rising edge of glitch source clock). At
scope.glitch.phase_shift_steps/2, the glitch rising edge is aligned
with the glitch source clock falling edge. Negative values are
allowed, but -x is equivalent to scope.glitch.phase_shift_steps-x. The
setting rolls over (+x is equivalent to
scope.glitch.phase_shift_steps+x). Run the notebook in
jupyter/demos/husky_glitch.ipynb to visualize glitch settings.</p>
<p>For other capture hardware (CW-lite, CW-pro), offset is expressed
as a percentage of one period.
A pulse may begin anywhere from -49.8% to 49.8% away from a rising
edge, allowing glitches to be swept over the entire clock cycle.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>very large negative offset &lt;-45 may result in double glitches
(CW-lite/pro only).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return an int (Husky) or float (CW-lite/pro) with the current
glitch offset.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the glitch offset. For CW-lite/pro, the new value is
rounded to the nearest possible offset.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>UserWarning</strong> – value outside range [-50, 50] (value is rounded)
    (CW-lite/pro only)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">GlitchSettings.</span></span><span class="sig-name descname"><span class="pre">clk_src</span></span></dt>
<dd><p>The clock signal that the glitch DCM is using as input.</p>
<dl class="simple">
<dt>This DCM can be clocked from three different sources:</dt><dd><ul class="simple">
<li><p>“target”: The HS1 clock from the target device (can also be AUX clock for Husky)</p></li>
<li><p>“clkgen”: The CLKGEN DCM output (N/A for Husky)</p></li>
<li><p>“pll”: Husky’s on-board PLL clock (Husky only)</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the clock signal currently in use</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the glitch clock source</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – New value not one of “target”, “clkgen” or “pll”</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.phase_shift_steps">
<span class="sig-prename descclassname"><span class="pre">GlitchSettings.</span></span><span class="sig-name descname"><span class="pre">phase_shift_steps</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.phase_shift_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of phase shift steps per target clock period.
Husky only.
To change, modify clock.pll.update_fpga_vco()</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns the number of steps.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.mmcm_locked">
<span class="sig-prename descclassname"><span class="pre">GlitchSettings.</span></span><span class="sig-name descname"><span class="pre">mmcm_locked</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.mmcm_locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Husky only. Whether the Xilinx MMCMs used to generate glitches are
locked or not.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.num_glitches">
<span class="sig-prename descclassname"><span class="pre">GlitchSettings.</span></span><span class="sig-name descname"><span class="pre">num_glitches</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererGlitch.GlitchSettings.num_glitches" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of glitch events to generate. CW-Husky only.</p>
<p>Each glitch event uses the same offset and width settings.
Glitch event x uses repeat[x] and ext_offset[x].</p>
<p>This parameter has no effect when scope.glitch.trigger_src is set to
“manual” or “continuous”.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – number outside of [1, 32].</p>
</dd>
</dl>
</dd></dl>

</div></blockquote>
</section>
</section>
<section id="pro-husky-only-featuers">
<h3>Pro/Husky Only Featuers<a class="headerlink" href="#pro-husky-only-featuers" title="Permalink to this heading">¶</a></h3>
<section id="sad">
<h4>SAD<a class="headerlink" href="#sad" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>Communicates with and drives the Sum of Absolute Differences module on the ChipWhisperer Pro.</p>
<p>Example for triggering off of some previously collected scope data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scope</span><span class="o">.</span><span class="n">SAD</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">wave</span><span class="p">[</span><span class="mi">1000</span><span class="p">:</span><span class="mi">1000</span><span class="o">+</span><span class="mi">128</span><span class="p">]</span> <span class="c1"># change 128 to 32 on Husky</span>
<span class="n">scope</span><span class="o">.</span><span class="n">SAD</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">scope</span><span class="o">.</span><span class="n">SAD</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">scope</span><span class="o">.</span><span class="n">trigger</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="s2">&quot;SAD&quot;</span>
<span class="n">scope</span><span class="o">.</span><span class="n">adc</span><span class="o">.</span><span class="n">basic_mode</span> <span class="o">=</span> <span class="s2">&quot;rising_edge&quot;</span>

<span class="c1">#can now capture as normal</span>
<span class="n">trace</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">capture_trace</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ChipWhispererSAD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oa</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD" title="Permalink to this definition">¶</a></dt>
<dd><p>Communicates with the SAD module inside the CW Pro</p>
<p>This submodule is only available on the ChipWhisperer1200 Pro</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">trace</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">capture_trace</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="n">cw</span><span class="o">.</span><span class="n">SAD</span><span class="o">.</span><span class="n">reference</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="mi">400</span><span class="p">:</span><span class="mi">528</span><span class="p">]</span>
<span class="n">cw</span><span class="o">.</span><span class="n">SAD</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">cw</span><span class="o">.</span><span class="n">SAD</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">cw</span><span class="o">.</span><span class="n">trigger</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="s1">&#39;SAD&#39;</span>

<span class="c1">#SAD trigger active</span>
<span class="n">trace</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">capture_trace</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.check_status">
<span class="sig-name descname"><span class="pre">check_status</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.check_status" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the SAD module is running &amp; outputting valid data</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.getThreshold">
<span class="sig-name descname"><span class="pre">getThreshold</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.getThreshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the threshold. When the SAD output falls below this threshold the system triggers</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.reference">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">reference</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the reference data for the SAD Trigger.</p>
<p>The reference must be 128 samples long. Through this interface,
it is represented as a numpy array of floats between -0.5 and 0.5
(the same as trace data).</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Gets the currently set SAD reference</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Sets the SAD reference</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – Data not 128 samples long</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the SAD hardware block. The ADC clock must be running!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.setRefWaveform">
<span class="sig-name descname"><span class="pre">setRefWaveform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataRef</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.setRefWaveform" title="Permalink to this definition">¶</a></dt>
<dd><p>Download a reference waveform. Resets the SAD module &amp; starts it again after loading the new data. ADC Clock must be running!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.setThreshold">
<span class="sig-name descname"><span class="pre">setThreshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.setThreshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the threshold. When the SAD output falls below this threshold the system triggers</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the SAD algorithm, which causes the reference data to be loaded from the FIFO</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.threshold">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">threshold</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAD.ChipWhispererSAD.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>The threshold for the SAD trigger.</p>
<p>The threshold has a maximum value of 100 000. You should set the
reference waveform via SAD.reference before setting this value.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current threshold</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the current threshold</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ValueError</strong> – The user attempted to set a threshold above 100 000</p></li>
<li><p><strong>IOError</strong> – User attempted to set the threshold before the reference
    waveform.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
</section>
<section id="husky-only-features">
<span id="api-scope-husky"></span><h3>Husky Only Features<a class="headerlink" href="#husky-only-features" title="Permalink to this heading">¶</a></h3>
<section id="scope-uarttrigger">
<h4>scope.UARTTrigger<a class="headerlink" href="#scope-uarttrigger" title="Permalink to this heading">¶</a></h4>
<p>UART Pattern Matching Trigger. Must set <code class="code docutils literal notranslate"><span class="pre">scope.trigger.module</span> <span class="pre">=</span> <span class="pre">'UART'</span></code> to select this trigger.</p>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UARTTrigger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scope</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace_reg_select</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">main_reg_select</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Husky UART trigger module settings.
Basic usage for triggering on ‘r’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#assuming setup scope:</span>
<span class="n">scope</span><span class="o">.</span><span class="n">trigger</span><span class="o">.</span><span class="n">triggers</span> <span class="o">=</span> <span class="s1">&#39;tio1&#39;</span>
<span class="n">scope</span><span class="o">.</span><span class="n">trigger</span><span class="o">.</span><span class="n">module</span> <span class="o">=</span> <span class="s1">&#39;UART&#39;</span>
<span class="n">scope</span><span class="o">.</span><span class="n">UARTTrigger</span><span class="o">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">scope</span><span class="o">.</span><span class="n">UARTTrigger</span><span class="o">.</span><span class="n">baud</span> <span class="o">=</span> <span class="mi">38400</span>
<span class="n">scope</span><span class="o">.</span><span class="n">UARTTrigger</span><span class="o">.</span><span class="n">set_pattern_match</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">scope</span><span class="o">.</span><span class="n">UARTTrigger</span><span class="o">.</span><span class="n">trigger_source</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>TraceWhisperer runs on the same hardware as this, so configuration changes
in one affects the other and vice-versa.</p>
<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.baud">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">baud</span></span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.baud" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the desired baud rate.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enabled</span></span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether trace data collecting is enabled or not. Mostly affects configuration
of the front 20-pin header.
:param enable:
:type enable: bool</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.matched_pattern_counts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matched_pattern_counts</span></span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.matched_pattern_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the actual trace data seen for the last matched pattern.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.matched_pattern_data">
<span class="sig-name descname"><span class="pre">matched_pattern_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.matched_pattern_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the actual trace data seen for the last matched pattern.
:param as_string: convert each byte to its boolean string; otherwise,
:type as_string: bool
:param results are returned as a list of self.data_bits-sized words.:</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.rules">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rules</span></span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut to self.capture.rules</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.rules_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rules_enabled</span></span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.rules_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut to self.capture.rules_enabled</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.sampling_clock">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sampling_clock</span></span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.sampling_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Shorthand for accessing the measured frequency of the sampling clock.
Indirectly set via ‘baud’ setting.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.set_pattern_match">
<span class="sig-name descname"><span class="pre">set_pattern_match</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enable_rule</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.set_pattern_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets pattern match and mask parameters.  The pattern may be
specified as a string (if the UART word size is 8 bits), or as a list
of self.data_bits-sized integers (as is done for trace).
Refer to set_pattern_match() documentation in parent TraceWhisperer
class for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> – match index [0-7]</p></li>
<li><p><strong>pattern</strong> – string or list of self.data_bits-sized integers.
Maximum size given by self.pattern_size.</p></li>
<li><p><strong>mask</strong> (<em>list</em><em>, </em><em>optional</em>) – list of self.data_bits-sized integers,
must have same size as ‘pattern’ if set.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.trigger_source">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">trigger_source</span></span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.trigger_source" title="Permalink to this definition">¶</a></dt>
<dd><p>Set which pattern match rule is used to generate a trigger.
:param rule:
:type rule: int</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.uart_data">
<span class="sig-name descname"><span class="pre">uart_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rawdata</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prepend_matched_pattern</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_ascii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.trace.TraceWhisperer.UARTTrigger.uart_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function to parse the captured UART data.
:param rawdata: raw capture data, list of lists, e.g. obtained from read_capture_data()
:type rawdata: list
:param prepend_matched_pattern:
:type prepend_matched_pattern: bool
:param return_ascii: return data as ASCII (otherwise hex)
:type return_ascii: bool</p>
</dd></dl>

</dd></dl>

</section>
<section id="scope-la">
<h4>scope.LA<a class="headerlink" href="#scope-la" title="Permalink to this heading">¶</a></h4>
<p>Built in logic analyzer for visualizing internal FPGA signals. Notably can
be used for visualizing glitch parameters, as in the
<a class="reference external" href="https://github.com/newaetech/chipwhisperer-jupyter/blob/master/demos/husky_glitch.ipynb">Husky Glitch Notebook</a></p>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LASettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmcm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scope</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings" title="Permalink to this definition">¶</a></dt>
<dd><p>Husky logic analyzer settings. For accessing recorded glitch generation, IO, and USERIO signals.</p>
<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.capture_depth">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">capture_depth</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.capture_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of bits captured for each signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>depth</strong> (<em>int</em>) – capture &lt;depth&gt; samples of each signal. 16-bit value, in range [1, scope.LA.max_capture_depth]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.capture_group">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">capture_group</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.capture_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets which group of signals are captured.</p>
<p>There are three groups. The signals captured for each group are as follows:
‘glitch’ (group 0):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>glitch output</p></li>
<li><p>source clock of glitch module</p></li>
<li><p>glitch internal MMCM1 (offset) output</p></li>
<li><p>glitch internal MMCM2 (width) output</p></li>
<li><p>glitch go internal signal</p></li>
<li><p>capture trigger</p></li>
<li><p>glitch enable</p></li>
<li><p>manual glitch trigger in source clock domain (e.g. signal 1 of this group)</p></li>
<li><p>glitch trigger in MMCM1 clock domain</p></li>
</ol>
</div></blockquote>
<p>‘CW 20-pin’ (group 1):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>IO1</p></li>
<li><p>IO2</p></li>
<li><p>IO3</p></li>
<li><p>IO4</p></li>
<li><p>HS1</p></li>
<li><p>HS2</p></li>
<li><p>AUX MCX</p></li>
<li><p>TRIG MCX</p></li>
<li><p>ADC sampling clock</p></li>
</ol>
</div></blockquote>
<p>‘USERIO 20-pin’ (group 2):</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>D0</p></li>
<li><p>D1</p></li>
<li><p>D2</p></li>
<li><p>D3</p></li>
<li><p>D4</p></li>
<li><p>D5</p></li>
<li><p>D6</p></li>
<li><p>D7</p></li>
<li><p>CK</p></li>
</ol>
</div></blockquote>
<p>‘trigger debug’ (group 3)
‘internal trace 1’ (group 4)
‘internal trace 2’ (group 5)
‘glitch debug’ (group 6)</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the capture group currently in use.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the capture group.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid capture group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.clk_source">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clk_source</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.clk_source" title="Permalink to this definition">¶</a></dt>
<dd><p>The clock signal that the logic analyzer is using to generate its sampling clock.</p>
<dl class="simple">
<dt>There are three different sources:</dt><dd><ul class="simple">
<li><p>“target”: The clock from the target device (from HS1 or AUX, as per scope.clock.clkgen_src)</p></li>
<li><p>“usb”: The 96 MHz internal USB clock.</p></li>
<li><p>“pll”: Husky’s on-board PLL clock.</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the clock signal currently in use</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the clock source</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – New value not one of “target”, “usb” or “pll”</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.clkgen_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkgen_enabled</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.clkgen_enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether the Xilinx MMCM used to generate the sampling clock
is powered on or not.  7-series MMCMs are power hungry. In the Husky
FPGA, MMCMs are estimated to consume close to half of the FPGA’s power.
If you run into temperature issues and don’t require the logic analyzer
or debug trace functionality, power down this MMCM.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.downsample">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">downsample</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.downsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample setting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>downsample</strong> (<em>int</em>) – capture every &lt;downsample&gt; samples. 16-bit value, in range [1, 2**16].</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enabled</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether this block is active for recording data. The LA
and trace components share the same FPGA storage, so they cannot be
simultaneously enabled.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.errors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">errors</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.errors" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate whether internal FPGA errors have occurred.
Write to clear.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.extract">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">extract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">raw</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.extract" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.fifo_empty">
<span class="sig-name descname"><span class="pre">fifo_empty</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.fifo_empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the capture FIFO is empty, False otherwise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.locked">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">locked</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.locked" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the sampling clock MMCM is locked (True or False).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.max_capture_depth">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_capture_depth</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.max_capture_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum capture depth.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.oversampling_factor">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">oversampling_factor</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.oversampling_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplier for the sampling clock.
Can be fractional, but an integer is probably what you want.
Whether the desired oversampling factor can be achieved depends on the
source clock frequency; a warning is issued if it can’t.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the actual oversampling factor.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the desired oversampling factor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.present">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">present</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.present" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the logic analyzer functionality is present in this build (True or False).
If it is not present, none of the functionality of this class is available.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.read_capture">
<span class="sig-name descname"><span class="pre">read_capture</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.read_capture" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns captured data for specified signal source.
What you get depends on the capture group; see the capture_group documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>source</strong> (<em>int</em>) – signal to read</p></li>
<li><p><strong>length</strong> (<em>int</em>) – number of byte to read. If unspecified, returns the full capture size
(which is implementation-dependent and can be learned from capture_depth)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Numpy array of binary values.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – invalid source</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.read_capture_data">
<span class="sig-name descname"><span class="pre">read_capture_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check_empty</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.read_capture_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Read captured data.</p>
<p>Returns: List of captured entries. Each list element is itself a 3-element list,
containing the 3 bytes that make up a capture entry. Use extract() to parse.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.reset_MMCM">
<span class="sig-name descname"><span class="pre">reset_MMCM</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.reset_MMCM" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the sampling clock’s MMCM.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.sampling_clock_frequency">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sampling_clock_frequency</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.sampling_clock_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the actual sampling clock frequency.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.source_clock_frequency">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">source_clock_frequency</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.source_clock_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the actual clock frequency of the input clock to the shared LA/trace MMCM.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.trigger_now">
<span class="sig-name descname"><span class="pre">trigger_now</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.trigger_now" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigger the capture manually.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.trigger_source">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">trigger_source</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LASettings.trigger_source" title="Permalink to this definition">¶</a></dt>
<dd><p>The trigger used by the logic analyzer to capture.</p>
<dl>
<dt>There are several different sources:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>“glitch”: The internal glitch enable trigger, one cycle earlier than the</dt><dd><p>glitch output seen when scope.glitch.output = ‘enable_only’. This
signal is in the MMCM1 clock glitch domain.</p>
</dd>
</dl>
</li>
<li><p>“capture”: The internal ADC capture trigger.</p></li>
<li><dl class="simple">
<dt>“glitch_source”: The internal manual glitch trigger in the source or target clock</dt><dd><p>domain (as per scope.glitch.clk_src), which accounts for
scope.glitch.ext_offset but not scope.glitch.offset. Should
only be used with scope.glitch.trigger_src = ‘manual’; may
not fire reliably with other settings.</p>
</dd>
</dl>
</li>
<li><p>“glitch_trigger”: The internal glitch trigger in the MMCM1 clock domain.</p></li>
<li><p>“trigger_glitch”: The trigger <em>for</em> the glitch module (aka scope.trigger.triggers).</p></li>
<li><p>“HS1”: The HS1 input clock.</p></li>
<li><p>“rising_userio_d[0-7]”: a rising edge (0-&gt;1) on a USERIO pin</p></li>
<li><p>“falling_userio_d[0-7]”: a falling edge (1-&gt;0) on a USERIO pin</p></li>
<li><p>“rising_tio[0-3]”: a rising edge (0-&gt;1) on a tio pin</p></li>
<li><p>“failling_tio[0-3]”: a falling edge (0-&gt;1) on a tio pin</p></li>
</ul>
<p>In addition, capture can be triggered manually, irrespective of the trigger_source
setting, by calling scope.LA.trigger_now()</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the trigger source currently in use</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Change the trigger source</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – New value not one of the options listed above.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="scope-ads4128settings">
<h4>scope.ADS4128Settings<a class="headerlink" href="#scope-ads4128settings" title="Permalink to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ADS4128Settings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Husky ADS4128 ADC settings. Mostly for testing, not needed in normal use.</p>
<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings.adc_reset">
<span class="sig-name descname"><span class="pre">adc_reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings.adc_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the ADC.
Note this is done by the FPGA - see reg_husky_adc.v</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings.hi_perf">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hi_perf</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings.hi_perf" title="Permalink to this definition">¶</a></dt>
<dd><p>High performance mode setting.
Valid values are 0 (high performance off), 1, and 2. See ADS4128 datasheet for more information.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the high performance mode setting.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the high performance mode setting.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings.low_speed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">low_speed</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings.low_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the ADC is set to “low speed” operation; recommended for sampling rates below 80 MS/s.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return whether the ADC is set to low speed mode.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the low speed mode.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings.mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mode</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.ADS4128Settings.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>The current mode of the ADC.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return the current ADC operating mode (“normal” or “test ramp”)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the operating mode.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if mode not one of “normal” or “test ramp”</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="scope-leds">
<h4>scope.LEDs<a class="headerlink" href="#scope-leds" title="Permalink to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LEDSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LEDSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LEDSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>Set source of Husky front-panel LEDs</p>
<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LEDSettings.setting">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">setting</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.LEDSettings.setting" title="Permalink to this definition">¶</a></dt>
<dd><p>Front-panel LED sources.</p>
<ol class="arabic simple">
<li><p>default: green=armed, blue=capture, top red=PLL lock fail, bottom red=glitch</p></li>
<li><p>green: USB clock heartbeat, blue=CLKGEN clock heartbeat</p></li>
<li><p>green: ADC sampling clock heartbeat, blue=PLL reference clock heartbeat</p></li>
<li><p>green: PLL clock heartbeat, blue=external clock change detected</p></li>
</ol>
<p>In all cases, blinking red lights indicate a temperature, voltage, or
sampling error (see scope.XADC.status and scope.adc.errors for details),
whlie blinking green and blue lights indicate that a frequency change
was detected on the external clock input (and that scope.clock should
be updated to account for this).</p>
</dd></dl>

</dd></dl>

</section>
<section id="scope-errors">
<h4>scope.errors<a class="headerlink" href="#scope-errors" title="Permalink to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.HuskyErrors">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HuskyErrors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">XADC</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.HuskyErrors" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather all the Husky error sources in one place.
Use scope.errors.clear() to clear them.</p>
</dd></dl>

</section>
<section id="scope-userio">
<h4>scope.userio<a class="headerlink" href="#scope-userio" title="Permalink to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">USERIOSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>Control Husky’s USERIO (20-pin front connector) interface.</p>
<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.direction">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">direction</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the direction of the USERIO data pins (D0-D7) with an
8-bit integer, where bit &lt;x&gt; determines the direction of D&lt;x&gt;;
bit x = 0: D&lt;x&gt; is an input to Husky.
bit x = 1: D&lt;x&gt; is driven by Husky.
When scope.userio.mode is not “normal”, then this setting is controlled
by the FPGA and cannot be changed by the user.
Use with care.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.drive_data">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">drive_data</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.drive_data" title="Permalink to this definition">¶</a></dt>
<dd><p>8-bit data to drive on the USERIO data bus.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.fpga_mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fpga_mode</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.fpga_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>When scope.userio.mode = ‘fpga_debug’, selects which FPGA signals
are routed to the USERIO pins. See cwhusky_top.v for definitions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.mode">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mode</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Set mode for USERIO pins:
“normal”: as defined by scope.userio.direction.
“trace”: for target trace capture.
“target_debug_jtag”: for target debugging with ChipWhisperer using MPSSE in JTAG mode
“target_debug_swd”: for target debugging with ChipWhisperer using MPSSE in SWD mode
“fpga_debug”: for FPGA debug (look to cwhusky_top.v for signal definitions).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.status">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">status</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.USERIOSettings.status" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns current value of header pins. LSB=D0, MSB=CK.</p>
</dd></dl>

</dd></dl>

</section>
<section id="scope-xadc">
<h4>scope.XADC<a class="headerlink" href="#scope-xadc" title="Permalink to this heading">¶</a></h4>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">XADCSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">oaiface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings" title="Permalink to this definition">¶</a></dt>
<dd><p>Husky FPGA XADC temperature and voltage monitoring.
XADC alarms are sticky and shut down generated clocks and SAD logic; the
error condition must be manually cleared (scope.XADC.status = 0) to re-enable
shutdown logic.</p>
<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.get_temp">
<span class="sig-name descname"><span class="pre">get_temp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.get_temp" title="Permalink to this definition">¶</a></dt>
<dd><p>Read XADC temperature.
:param addr: DRP address (0: current; 32: max; 36: min)
:type addr: int</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Temperature in celcius (float).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.get_vcc">
<span class="sig-name descname"><span class="pre">get_vcc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vccint'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'current'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.get_vcc" title="Permalink to this definition">¶</a></dt>
<dd><p>Read XADC vcc.
:param rail: ‘vccint’, ‘vccaux’, or ‘vccbram’
:type rail: string
:param value: ‘current’, ‘min’, or ‘max’
:type value: string</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>voltage (float).</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.max_temp">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_temp</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.max_temp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the highest observed FPGA temperature.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.ot_temp_reset">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ot_temp_reset</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.ot_temp_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>FPGA over-temperature reset.
When the FPGA temperature returns below this value, the error condition
triggered by ot_temp_trigger is cleared.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.ot_temp_trigger">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ot_temp_trigger</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.ot_temp_trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>FPGA over-temperature trigger.
If the FPGA temperature exceeds this value, an error is flagged, and
all clock-generating modules are shut down until the temperature
returns below ot_temp_reset (since they are very power hungry).
Read-only.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.set_temp">
<span class="sig-name descname"><span class="pre">set_temp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">temp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">addr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.set_temp" title="Permalink to this definition">¶</a></dt>
<dd><p>Set XADC temperature thresholds.
:param addr: DRP address
:type addr: int
:param temp: temperature threshold [celcius]
:type temp: float</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Temperature in celcius (float).</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.status">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">status</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.status" title="Permalink to this definition">¶</a></dt>
<dd><p>Read XADC alarm status bits
:Getter: Returns status string.</p>
<dl class="field-list simple">
<dt class="field-odd">Setter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Clear the status error bits (they are sticky).</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.temp">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">temp</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.temp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current FPGA temperature.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.temp_reset">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">temp_reset</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.temp_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>FPGA user temperature reset.
When the FPGA temperature returns below this value, the error condition
triggered by temp_trigger is cleared.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.temp_trigger">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">temp_trigger</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.temp_trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>FPGA user temperature trigger.
If the FPGA temperature exceeds this value, an error is flagged, and
all clock-generating modules are shut down until the temperature
returns below temp_reset (since they are very power hungry).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.vccaux">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vccaux</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.vccaux" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current VCCaux value.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.vccbram">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vccbram</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.vccbram" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current VCCbram value.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.vccint">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vccint</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererHuskyMisc.XADCSettings.vccint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current VCCint value.</p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>
<section id="chipwhisperer-nano-scope">
<span id="api-scope-cwnano"></span><h2>ChipWhisperer Nano Scope<a class="headerlink" href="#chipwhisperer-nano-scope" title="Permalink to this heading">¶</a></h2>
<p>Supported scopes:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference external" href="https://rtfm.newae.com/Capture/ChipWhisperer-Nano/">ChipWhisperer-Nano</a></p></li>
</ul>
</div></blockquote>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.scopes.CWNano">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CWNano</span></span><a class="headerlink" href="#chipwhisperer.scopes.CWNano" title="Permalink to this definition">¶</a></dt>
<dd><p>CWNano scope object.</p>
<p>This class contains the public API for the CWNano hardware. It includes
specific settings for each of these devices.</p>
<p>To connect to one of these devices, the easiest method is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">chipwhisperer</span> <span class="k">as</span> <span class="nn">cw</span>
<span class="n">scope</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">scopes</span><span class="o">.</span><span class="n">CWNano</span><span class="p">)</span>
</pre></div>
</div>
<p>Some sane default settings can be set using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">scope</span><span class="o">.</span><span class="n">default_setup</span><span class="p">()</span>
</pre></div>
</div>
<p>For more help about scope settings, try help() on each of the ChipWhisperer
scope submodules (scope.adc, scope.io, scope.glitch):</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes.cwnano.ADCSettings" title="chipwhisperer.capture.scopes.cwnano.ADCSettings"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.adc</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings" title="chipwhisperer.capture.scopes.cwnano.GPIOSettings"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.io</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.scopes.cwnano.GlitchSettings" title="chipwhisperer.capture.scopes.cwnano.GlitchSettings"><code class="xref py py-attr docutils literal notranslate"><span class="pre">scope.glitch</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.CWNano.default_setup" title="chipwhisperer.scopes.CWNano.default_setup"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.default_setup</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.CWNano.con" title="chipwhisperer.scopes.CWNano.con"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.con</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.CWNano.dis" title="chipwhisperer.scopes.CWNano.dis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.dis</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.CWNano.get_last_trace" title="chipwhisperer.scopes.CWNano.get_last_trace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.get_last_trace</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.CWNano.arm" title="chipwhisperer.scopes.CWNano.arm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.arm</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.scopes.CWNano.capture" title="chipwhisperer.scopes.CWNano.capture"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.capture</span></code></a></p></li>
<li><p><a class="reference internal" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.get_serial_ports" title="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.get_serial_ports"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scope.get_serial_ports</span></code></a></p></li>
</ul>
</div></blockquote>
<p>Inherits from <a class="reference internal" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface" title="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.CWNano.arm">
<span class="sig-name descname"><span class="pre">arm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.CWNano.arm" title="Permalink to this definition">¶</a></dt>
<dd><p>Arm the ADC, the trigger will be GPIO4 rising edge (fixed trigger).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.CWNano.capture">
<span class="sig-name descname"><span class="pre">capture</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poll_done</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.CWNano.capture" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises IOError if unknown failure, returns ‘True’ if timeout, ‘False’ if no timeout</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.CWNano.con">
<span class="sig-name descname"><span class="pre">con</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.CWNano.con" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects to attached chipwhisperer hardware (Nano)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sn</strong> (<em>str</em>) – The serial number of the attached device. Does not need to
be specified unless there are multiple devices attached.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if connection is successful, False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.CWNano.default_setup">
<span class="sig-name descname"><span class="pre">default_setup</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.CWNano.default_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up sane capture defaults for this scope</p>
<blockquote>
<div><ul class="simple">
<li><p>7.5MHz ADC clock</p></li>
<li><p>7.5MHz output clock</p></li>
<li><p>5000 capture samples</p></li>
<li><p>tio1 = serial rx</p></li>
<li><p>tio2 = serial tx</p></li>
<li><p>glitch module off</p></li>
</ul>
</div></blockquote>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.1: </span>Added default setup for CWNano</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.CWNano.dis">
<span class="sig-name descname"><span class="pre">dis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.CWNano.dis" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnects the current scope object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the disconnection was successful, False otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.CWNano.get_last_trace">
<span class="sig-name descname"><span class="pre">get_last_trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">as_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.CWNano.get_last_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the last trace captured with this scope.</p>
<p>Can return traces as floating point values (<code class="code docutils literal notranslate"><span class="pre">as_int=False</span></code>)
or as integers.</p>
<p>Floating point values are scaled and shifted to be between -0.5 and 0.5.</p>
<p>Integer values are raw readings from the ChipWhisperer ADC. The ChipWhisperer-Lite
has a 10-bit ADC, the Nano has an 8-bit ADC, and the Husky can read either
8-bits or 12-bits of ADC data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>as_int</strong> (<em>bool</em>) – If False, return trace as a float. Otherwise, return as an int.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Numpy array of the last capture trace.</p>
</dd>
</dl>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 5.6.1: </span>Added as_int parameter</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.CWNano.reset_clock_phase">
<span class="sig-name descname"><span class="pre">reset_clock_phase</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.CWNano.reset_clock_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the target and adc clocks, resetting their phase</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>causes an interruption in the target clock. You may need to reset the target.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.scopes.CWNano.vglitch_setup">
<span class="sig-name descname"><span class="pre">vglitch_setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">glitcht</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_setup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.scopes.CWNano.vglitch_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up sane defaults for voltage glitch</p>
<p>repeat = 1
ext_offset = 0</p>
</dd></dl>

</dd></dl>

<section id="adc">
<h3>adc<a class="headerlink" href="#adc" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.ADCSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ADCSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">usb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.ADCSettings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.ADCSettings.clk_freq">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clk_freq</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.ADCSettings.clk_freq" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the frequency for CLKOUT. Will be rounded to nearest possible values, check results to see
programmed value. Set to ‘None’ for disabling (High-Z) output.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns the actual frequency for CLKOUT</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Sets CLKOUT to the nearest possible value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.ADCSettings.clk_src">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clk_src</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.ADCSettings.clk_src" title="Permalink to this definition">¶</a></dt>
<dd><p>ADC Clock source.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns ‘int’ or ‘ext’ based on the clock source.</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>(str) Set the ADC clock source to either internal or external:
(‘int’ or ‘ext’)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.ADCSettings.samples">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">samples</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.ADCSettings.samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of samples to store.</p>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
<section id="io">
<h3>io<a class="headerlink" href="#io" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GPIOSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">usb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings.cdc_settings">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cdc_settings</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings.cdc_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Check or set whether USART settings can be changed via the USB CDC connection</p>
<p>i.e. whether you can change USART settings (baud rate, 8n1) via a serial client like PuTTY</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>An array of length two for two possible CDC serial ports (though only one is used)</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Can set either via an integer (which sets both ports) or an array of length 2 (which sets each port)</p>
</dd>
</dl>
<p>Returns None if using firmware before the CDC port was added</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings.clkout">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">clkout</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings.clkout" title="Permalink to this definition">¶</a></dt>
<dd><p>“Set the frequency for CLKOUT. Will be rounded to nearest possible values, check results to see
programmed value. Set to ‘None’ for disabling (High-Z) output.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings.nrst">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nrst</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings.nrst" title="Permalink to this definition">¶</a></dt>
<dd><p>The state of the NRST pin.</p>
<p>See pdic for more information.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings.pdic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pdic</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings.pdic" title="Permalink to this definition">¶</a></dt>
<dd><p>The state of the PDIC pin output pin.</p>
<dl class="simple">
<dt>This is a GPIO pin. The following values are allowed:</dt><dd><ul class="simple">
<li><p>“high” / True: logic 1</p></li>
<li><p>“low” / False: logic 0</p></li>
<li><p>“disabled” / “default” / “high_z” / None: undriven</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return one of “high”, “low”, or “high_z”</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the pin’s state
Raises: ValueError if new state not listed above</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings.pdid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pdid</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings.pdid" title="Permalink to this definition">¶</a></dt>
<dd><p>The state of the PDID pin.</p>
<p>See pdic for more information.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings.tio1">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tio1</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings.tio1" title="Permalink to this definition">¶</a></dt>
<dd><p>The function of the Target IO1 pin.</p>
<dl class="simple">
<dt>TIO1 can be used for the following functions:</dt><dd><ul class="simple">
<li><p>“serial_rx”: UART input</p></li>
</ul>
</dd>
</dl>
<p>Default value is “serial_rx”.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return None</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the Target IO1 mode.
Raises: ValueError if new value is not one of the above modes</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings.tio2">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tio2</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings.tio2" title="Permalink to this definition">¶</a></dt>
<dd><p>The function of the Target IO2 pin.</p>
<dl class="simple">
<dt>TIO2 can be used for the following functions:</dt><dd><ul class="simple">
<li><p>“serial_tx”: UART output</p></li>
</ul>
</dd>
</dl>
<p>Default value is “serial_tx”.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return None</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the Target IO2 mode.
Raises: ValueError if new value is not one of the above modes</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings.tio3">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tio3</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings.tio3" title="Permalink to this definition">¶</a></dt>
<dd><p>The function of the Target IO3 pin.</p>
<dl class="simple">
<dt>TIO3 can be used for the following functions:</dt><dd><ul class="simple">
<li><p>“high_z” / None: High impedance input</p></li>
<li><p>“gpio_low” / False: Driven output: logic 0</p></li>
<li><p>“gpio_high” / True: Driven output: logic 1</p></li>
<li><p>“gpio_disabled”: Driven output: no effect</p></li>
</ul>
</dd>
</dl>
<p>Default value is “high_z”.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return one of the above strings</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the Target IO3 mode.
Raises: ValueError if new value is not one of the above modes</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GPIOSettings.tio4">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tio4</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GPIOSettings.tio4" title="Permalink to this definition">¶</a></dt>
<dd><p>The function of the Target IO4 pin.</p>
<dl class="simple">
<dt>TIO4 can be used for the following functions:</dt><dd><ul class="simple">
<li><p>“high_z” / None: High impedance input</p></li>
</ul>
</dd>
</dl>
<p>Default value is “high_z”. Typically, this pin is used as a trigger
input.</p>
<dl class="field-list simple">
<dt class="field-odd">Getter<span class="colon">:</span></dt>
<dd class="field-odd"><p>Return None</p>
</dd>
<dt class="field-even">Setter<span class="colon">:</span></dt>
<dd class="field-even"><p>Set the Target IO4 mode
Raises: ValueError if new value is not one of the above modes</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
<section id="id1">
<h3>glitch<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h3>
<blockquote>
<div><dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GlitchSettings">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">GlitchSettings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">usb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GlitchSettings" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GlitchSettings.ext_offset">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ext_offset</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GlitchSettings.ext_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset from rising edge of trigger &amp; when glitch gets inserted, approx = 8.3 ns * ext_offset</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GlitchSettings.manualTrigger">
<span class="sig-name descname"><span class="pre">manualTrigger</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GlitchSettings.manualTrigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Manually trigger the glitch</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwnano.GlitchSettings.repeat">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">repeat</span></span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwnano.GlitchSettings.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Width of glitch in cycles (approx = 8.3 ns * width)</p>
</dd></dl>

</dd></dl>

</div></blockquote>
</section>
</section>
<section id="common-scope-attributes">
<span id="api-scope-common"></span><h2>Common Scope Attributes<a class="headerlink" href="#common-scope-attributes" title="Permalink to this heading">¶</a></h2>
<p>The following methods and attributes are common to all scopes, as well as the CW305/CW310:</p>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ChipWhispererCommonInterface</span></span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.enable_MPSSE">
<span class="sig-name descname"><span class="pre">enable_MPSSE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.enable_MPSSE" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable MPSSE mode</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.check_feature">
<span class="sig-name descname"><span class="pre">check_feature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raise_exception</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.check_feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a feature is available on this ChipWhisperer</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.feature_list">
<span class="sig-name descname"><span class="pre">feature_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.feature_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of supported features that depend on device/firmware version</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface._getNAEUSB">
<span class="sig-name descname"><span class="pre">_getNAEUSB</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface._getNAEUSB" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">NAEUSB</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.get_serial_ports">
<span class="sig-name descname"><span class="pre">get_serial_ports</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.get_serial_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Get serial ports associated with a ChipWhisperer</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.5: </span>Add get_serial_ports()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-data docutils literal notranslate"><span class="pre">Optional</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">List</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.upgrade_firmware">
<span class="sig-name descname"><span class="pre">upgrade_firmware</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.upgrade_firmware" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempt a firmware upgrade. See <a class="reference external" href="https://chipwhisperer.readthedocs.io/en/latest/firmware.html">https://chipwhisperer.readthedocs.io/en/latest/firmware.html</a> for more information.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.6.1: </span>Improved programming interface</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.reset_sam3u">
<span class="sig-name descname"><span class="pre">reset_sam3u</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.reset_sam3u" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the ChipWhisperer’s microcontroller</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.6.1: </span>Add common cw interface</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.latest_fw">
<span class="sig-name descname"><span class="pre">latest_fw</span></span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.latest_fw" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the newest firmware as a dict with elements major, minor and debug</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.latest_fw_str">
<span class="sig-name descname"><span class="pre">latest_fw_str</span></span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.latest_fw_str" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.fw_version">
<span class="sig-name descname"><span class="pre">fw_version</span></span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.fw_version" title="Permalink to this definition">¶</a></dt>
<dd><p>Get current firmware version as a dict with elements major, minor and debug</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code>[<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.fw_version_str">
<span class="sig-name descname"><span class="pre">fw_version_str</span></span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.fw_version_str" title="Permalink to this definition">¶</a></dt>
<dd><p>A string of the firmware version:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;x.y.z&#39;</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.sam_build_date">
<span class="sig-name descname"><span class="pre">sam_build_date</span></span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.sam_build_date" title="Permalink to this definition">¶</a></dt>
<dd><p>The date the SAM3U firmware was built on</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 5.6.1: </span>Added sam build date to chipwhisperer</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.sn">
<span class="sig-name descname"><span class="pre">sn</span></span><a class="headerlink" href="#chipwhisperer.capture.api.cwcommon.ChipWhispererCommonInterface.sn" title="Permalink to this definition">¶</a></dt>
<dd><p>The USB serial number of this scope.</p>
<p>Can be passed to cw.scope() to specify which ChipWhisperer to connect to</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="firmware-update">
<span id="api-scope-update"></span><h2>Firmware Update<a class="headerlink" href="#firmware-update" title="Permalink to this heading">¶</a></h2>
<p>A simplified method of updating firmware has been added as of ChipWhisperer 5.6.0. This new method
is documented at <a class="reference internal" href="firmware.html#updating-firmware"><span class="std std-ref">Updating Firmware</span></a>.</p>
<p>For versions 5.5.2 and below, you must follow the directions below:</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>You can also use the BOSSA
<a class="reference external" href="https://www.shumatech.com/web/products/bossa">BOSSA</a> utiltiy
to reflash the SAM3U firmware. If you need to build it from source,
NewAE keeps a slightly modified version of the source at
<a class="reference external" href="https://github.com/newaetech/BOSSA">https://github.com/newaetech/BOSSA</a>. This utility does <strong>NOT</strong> support the CWNano.</p>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAM3Update.SAMFWLoader">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SAMFWLoader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scope=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logfunc=&lt;built-in</span> <span class="pre">function</span> <span class="pre">print&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAM3Update.SAMFWLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>Object for easy reprogramming of ChipWhisperers</p>
<p>See <a class="reference external" href="https://chipwhisperer.readthedocs.io/en/latest/firmware.html">https://chipwhisperer.readthedocs.io/en/latest/firmware.html</a>
for information on how to update.</p>
<p>Can autoprogram if the ChipWhisperer’s firmware has not already been erased.</p>
<p>Autoprogram Example:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Attach the scope part of the hardware to your computer.</p></li>
<li><p>Connect to the scope using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">chipwhisperer</span> <span class="k">as</span> <span class="nn">cw</span>

<span class="c1"># Connect to scope</span>
<span class="n">scope</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">scope</span><span class="p">()</span>

<span class="c1"># If using CW305, connect to target as well</span>
<span class="c1"># Can ignore msg about no bitstream</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">cw</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">CW305</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
<ol class="arabic">
<li><p>Call the auto_program() method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">programmer</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">SAMFWLoader</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="n">scope</span><span class="p">)</span>
<span class="c1"># if CW305</span>
<span class="c1"># programmer = cw.SAMFWLoader(scope=target)</span>

<span class="n">programmer</span><span class="o">.</span><span class="n">auto_program</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ol>
<p class="rubric">Example</p>
<ol class="arabic">
<li><p>Attach the scope part of the hardware to your computer.</p></li>
<li><p>Connect to the scope using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">chipwhisperer</span> <span class="k">as</span> <span class="nn">cw</span>

<span class="c1"># Connect to scope</span>
<span class="n">scope</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">scope</span><span class="p">()</span>

<span class="c1"># If using CW305, connect to target as well</span>
<span class="c1"># Can ignore msg about no bitstream</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">target</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">cw</span><span class="o">.</span><span class="n">targets</span><span class="o">.</span><span class="n">CW305</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Place the hardware in bootloader mode using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># use created scope object from previous step</span>
<span class="n">programmer</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">SAMFWLoader</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="n">scope</span><span class="p">)</span>

<span class="c1"># or CW305 target object</span>
<span class="n">programmer</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">SAMFWLoader</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>

<span class="c1"># WARNING: this will erase the firmware on the device</span>
<span class="c1"># and make it unusable until reprogrammed.</span>
<span class="n">programmer</span><span class="o">.</span><span class="n">enter_bootloader</span><span class="p">(</span><span class="n">really_enter</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Unplug then plug in the hardware into your computer again.
The device should be shown as BOSSA in the device manager
on Windows. Make not of the port number the BOSSA device
is attached to (for example: COM1, or COM2, and so on)</p></li>
<li><p>Program the SAM3U with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">chipwhisperer</span> <span class="k">as</span> <span class="nn">cw</span>
<span class="n">programmer</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="n">SAMFWLoader</span><span class="p">(</span><span class="n">scope</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>Two methods:</p>
<blockquote>
<div><ol class="arabic">
<li><p>Using the firmware_path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># the firmware file is included with chipwhisperer</span>
<span class="c1"># and is the .bin file from the FW build</span>
<span class="c1"># (ChipWhisperer Lite) chipwhisperer\hardware\capture\chipwhisperer-lite\sam3u_fw\SAM3U_VendorExample\Debug</span>
<span class="c1"># directory.</span>
<span class="n">programmer</span><span class="o">.</span><span class="n">program</span><span class="p">(</span><span class="o">&lt;</span><span class="n">port</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">path</span> <span class="n">to</span> <span class="n">firmware</span> <span class="n">file</span><span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Using the hardware_type (recommended):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">programmer</span><span class="o">.</span><span class="n">program</span><span class="p">(</span><span class="o">&lt;</span><span class="n">port</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">hardware_type</span><span class="o">=</span><span class="s1">&#39;cwlite&#39;</span><span class="p">)</span>
<span class="n">programmer</span><span class="o">.</span><span class="n">program</span><span class="p">(</span><span class="o">&lt;</span><span class="n">port</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">hardware_type</span><span class="o">=</span><span class="s1">&#39;cwnano&#39;</span><span class="p">)</span>
<span class="n">programmer</span><span class="o">.</span><span class="n">program</span><span class="p">(</span><span class="o">&lt;</span><span class="n">port</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">hardware_type</span><span class="o">=</span><span class="s1">&#39;cw305&#39;</span><span class="p">)</span>
<span class="n">programmer</span><span class="o">.</span><span class="n">program</span><span class="p">(</span><span class="o">&lt;</span><span class="n">port</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">hardware_type</span><span class="o">=</span><span class="s1">&#39;cw1200&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
<p>On Linux instead of ‘COM#’ use the Linux equivalent (usually /dev/ttyACM# or /dev/ttyUSB#)</p>
</li>
<li><p>Once the programming is done. Unplug then plug in the hardware into your
computer again. The device should show up as a ChipWhisperer again.</p></li>
</ol>
<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAM3Update.SAMFWLoader.enter_bootloader">
<span class="sig-name descname"><span class="pre">enter_bootloader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">really_enter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAM3Update.SAMFWLoader.enter_bootloader" title="Permalink to this definition">¶</a></dt>
<dd><p>Enters the bootloader of the ChipWhisperer by erasing the flash</p>
<p>Only use this if you want to erase the scope’s firmware (i.e. the
ChipWhisperer Lite). This does NOT erase the firmware of a target (
i.e. an STM32 target). Will raise a Warning the first time an erase
is attempted and really_enter=False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>really_enter</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, enter the bootloader
without ever raising a warning. If False, raise a warning
if this is the user’s first time calling it.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Warning</strong> – really_enter=False and user hasn’t seen this warning
    before</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAM3Update.SAMFWLoader.program">
<span class="sig-name descname"><span class="pre">program</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">port</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fw_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hardware_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bypass_warning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAM3Update.SAMFWLoader.program" title="Permalink to this definition">¶</a></dt>
<dd><p>Program the ChipWhisperer with new firmware.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>port</strong> (<em>str</em>) – Serial port that the ChipWhisperer bootloader is on</p></li>
<li><p><strong>fw_path</strong> (<em>str</em>) – Path to firmware, if specified leave out hardware type.</p></li>
<li><p><strong>hardware_type</strong> (<em>str</em>) – The type of hardware that you want to program.
If specified leave out fw_path. Valid types: (cwlite, cwnano, cw305, cw1200)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if programming succeeded, False if it didn’t</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAM3Update.SAMFWLoader.auto_program">
<span class="sig-name descname"><span class="pre">auto_program</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#chipwhisperer.capture.scopes.cwhardware.ChipWhispererSAM3Update.SAMFWLoader.auto_program" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase and program firmware of ChipWhisperer</p>
<p>Autodetects comport and hardware type.</p>
</dd></dl>

</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, NewAE Technology Inc..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/scope-api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/newaetech/chipwhisperer" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>